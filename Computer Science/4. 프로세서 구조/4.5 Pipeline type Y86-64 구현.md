* Y86-64 ISA를 효과적인 파이프라인 형 프로세서로 구현
* PC 계산을 선입 단계로 이동해 SEQ 최적화

## 4.5.1 SEQ+ 계산 단계 재배치하기

* SEQ+ 설계
	* PC 갱신 단계를 클럭 사이클의 맨 처음에 오도록 하는 것

* 보통 PC 갱신 단계에서 현재 인스트럭션을 위한 PC 값을 계산하도록해 다음 클럭 사이클 시작에서 로직이 작동하도록 한다
* 모든 사이클에서 이전 사이클 동안에 생성된 제어신호응 저장하는 레지스터 생성
	* PC 갱신 단계를 끌어온 댓가
	* picode pCnd

*  회로 타이밍 변경 기법
	*  어떤 시스템의 상태를 논리적 동작으로 바꾸지 않으며 변경한다
	*  시스템 지연 시간 조절을 위해 사용

## 신호의 재배치와 재명명

* 파이프 라인 설계에서는 시스템을 통해 흘러가는 여러 인스트럭션에 연계된 여러 버전 값이 존재한다
	* 여러 버전 값이 존재하기에 혼란을 방지하기 위해 신호를 재배치해야한다
*  pipe- 설계
	*  해당 단계 이름의 맨 앞 소문자를 때서 이름 붙임
	*  특정 인스트럭션에 관한 모든 정보를 한 개의 파이프 라인 단계 내에 유지하기 원함

## 다음 PC 값 측정

* PC 값 예측의 필요성과 이유
	* 매 클럭 사이클과 새 인스트럭션을 실행하기 위해
* 파이프 라인 설계의 궁극적 목적
	* 매 클럭 싸이클 마다 새로운 인스트럭션을 실행(완료)하는 것
* 선입한 인스트럭션이 조건부 분기 명령이면 실행 단계까지 진행되기전에 분기 여부를 알 수 없음
* 선입한 인스트럭션이 ret면 메모리 단계가 실행되기 전엔 리턴 위치 결정 x
* 나머지 인스트럭션은 다음 인스트럭션 주소 결정 가능
* 분기 예측
	* 분기 방향 추측하고 추측 결과에 따라 인스트럭션을 선입하는 기술

## 파이프라인 해저드

* 위험 요소인 의존성 문제 해결 및 원인 이해
* 데이터 의존성
	* 한 개의 인스트럭션의 결과가 다음 단계에 영향을 미치는 것
	* __스톨링__
		* halt 인스트럭션을 fetch 단계에 고정 시킴(PC를 고정시켜서 구현함)
			* 스톨이 종료되기 전까지 데이터 hazard가 발생하는 지점인 인스트럭션이 뒤에 오는 인스트럭션을 중재
		* 버블을 삽입한다 (동적으로 생성된 nop)
			* 메모리, 레지스터, 조건코드, 프로그램 상태를 변경하지 않음
			* 해독 단계에 hazard 발생시키는 인스트럭션을 잡아 놓는다
			* 싸이클을 미루는 것 같은 효과를 얻음
		* 전체 처리량 감소
