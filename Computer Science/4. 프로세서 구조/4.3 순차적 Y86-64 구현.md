* SEQ(순차적 프로세서)
	* 한 개의 인스트럭션을 처리할 때 필요한 모든 단계를 실행한다
	* 매우 긴 사이클 시간이 걸리고, 클럭 속도 저하 유발

## 4.3.1 작업 단계 구성하기
* 보통 cpu들 보면 fetch - decode -  execute - Writeback으로 단계 구성이 되어있다
	* Y86-64는 좀 더 세분화 되어 있다
	* 메모리와 레지스터에 접근하는 것에 따라 해독 단계를 분리했는데 이해를 돕기위해 그런듯


* 인스트럭션 처리 단계
* 선입(fetch)
	* PC를 메모리 주소를 사용해, 메모리로부터 인스트럭션 바이트를 읽음
	* 지금 실행 중인 인스트럭션의 순차적인 다음 인스트럭션의 주소 추출
* 해독(decode)
	* 레지스터 파일에서 오퍼랜드를 읽어온다
	* 스택 포인터를 읽기도 한다
* 실행(excution)
	* ALU가 인스트럭션이 지시하는 연산 수행
	* 메모리 참조기 유효 주소 계산, 스택 포인터 변경
	* 점프 인스트럭션에 대해 분기를 해야하는지 여부 결정
* 메모리
	* 데이터를 메모리에서 읽어들일 수 있다
* 재기록
	* 재기록 단계에서는 결과를 레지스터 파일에 기록
* PC 갱신
	* PC는 인스트럭션 주소 설정

## SEQ 하드웨어 구조

* 처리 단계에서 하는 일
* 선입
	* PC를 주소로 사용함
	* 인스트럭션 메모리가 인스트럭션 바이트를 읽음
* 해독
	* 레지스터 파일의 읽기 포트 A와 B를 valA,valB를 입력 받는데 사용
	* 동시에 읽을 수 있음
* 실행
	* ALU 연산
	* 조건 코드 레지스터
	* 스택 포인터 계산
	* 유효 주소 계산
* 메모리
	* 메모리 인스트럭션 실행시 메모리 워드에 읽거나 쓴다
* 재기록
	* E port 는 ALU 값 계산
	* M port 는 메모리에서 읽어온 값 계산
* PC 갱신
	* 인스트럭션 주소
	* 목적지 주소
	* 리턴 주소

## SEQ TIMING

* 학습의 이유는 트리거에 따른 동작변화 알기
* 순차적으로 할당문이 실행된다

* 조합 논리회로는 순차처리나 처리를 필요로 하지 않는다
	 * 입력이 바뀔 때 마다 논리 게이트의 네트워크를 통해 값들이 변화한다
 * 우리의 SEQ는 조합 논리회로와 2가지 형태의 메모리 장치를 사용한다
	 * 레지스터(PC , 조건 코드 레지스터)
	 * 랜덤 액세스 메모리(레지스터 파일, 인스트럭션 메모리, 데이터 메모리)
 * 인스트럭션 메모리를 조합 논리회로 처럼 사용함
	 * 인스트럭션을 읽어들일 때만 사용하기 때문이다
 * PC, CCC DataMemory, Register file은 하나의 클럭 신호로 레지스터와 랜덤 액세스 메모리에 접근한다
	 * 레지스터들과 메모리에 클럭을 공급하는 것은  프로세스의 순차제어에 꼭 필요하다
 * 클럭이 low와 high로 전환이 이루어지는 매 시점마다 프로세서 실행
