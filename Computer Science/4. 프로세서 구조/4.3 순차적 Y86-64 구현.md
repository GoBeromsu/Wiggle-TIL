* SEQ(순차적 프로세서)
	* 한 개의 인스트럭션을 처리할 때 필요한 모든 단계를 실행한다
	* 매우 긴 사이클 시간이 걸리고, 클럭 속도 저하 유발

## 4.3.1 작업 단계 구성하기
* 보통 cpu들 보면 fetch - decode -  execute - Writeback으로 단계 구성이 되어있다
	* Y86-64는 좀 더 세분화 되어 있다
	* 메모리와 레지스터에 접근하는 것에 따라 해독 단계를 분리했는데 이해를 돕기위해 그런듯


* 인스트럭션 처리 단계
* 선입(fetch)
	* PC를 메모리 주소를 사용해, 메모리로부터 인스트럭션 바이트를 읽음
	* 지금 실행 중인 인스트럭션의 순차적인 다음 인스트럭션의 주소 추출
* 해독(decode)
	* 레지스터 파일에서 오퍼랜드를 읽어온다
	* 스택 포인터를 읽기도 한다
* 실행(excution)
	* ALU가 인스트럭션이 지시하는 연산 수행
	* 메모리 참조기 유효 주소 계산, 스택 포인터 변경
	* 점프 인스트럭션에 대해 분기를 해야하는지 여부 결정
* 메모리
	* 데이터를 메모리에서 읽어들일 수 있다
* 재기록
	* 재기록 단계에서는 결과를 레지스터 파일에 기록
* PC 갱신
	* PC는 인스트럭션 주소 설정

## SEQ 하드웨어 구조

* 처리 단계에서 하는 일
* 선입
	* PC를 주소로 사용함
	* 인스트럭션 메모리가 인스트럭션 바이트를 읽음
* 해독
	* 레지스터 파일의 읽기 포트 A와 B를 valA,valB를 입력 받는데 사용
	* 동시에 읽을 수 있음
* 실행
	* ALU 연산
	* 조건 코드 레지스터
	* 스택 포인터 계산
	* 유효 주소 계산
* 메모리
	* 메모리 인스트럭션 실행시 메모리 워드에 읽거나 쓴다
* 재기록
	* E port 는 ALU 값 계산
	* M port 는 메모리에서 읽어온 값 계산
* PC 갱신
	* 인스트럭션 주소
	* 목적지 주소
	* 리턴 주소

## SEQ TIMING

* 학습의 이유는 트리거에 따른 동작변화 알기
* 순차적으로 할당문이 실행된다

* 조합 논리회로는 순차처리나 처리를 필요로 하지 않는다
	 * 입력이 바뀔 때 마다 논리 게이트의 네트워크를 통해 값들이 변화한다
 * 우리의 SEQ는 조합 논리회로와 2가지 형태의 메모리 장치를 사용한다
	 * 레지스터(PC , 조건 코드 레지스터)
	 * 랜덤 액세스 메모리(레지스터 파일, 인스트럭션 메모리, 데이터 메모리)
 * 인스트럭션 메모리를 조합 논리회로 처럼 사용함
	 * 인스트럭션을 읽어들일 때만 사용하기 때문이다
 * PC, CCC DataMemory, Register file은 하나의 클럭 신호로 레지스터와 랜덤 액세스 메모리에 접근한다
	 * 레지스터들과 메모리에 클럭을 공급하는 것은  프로세스의 순차제어에 꼭 필요하다
 * 클럭이 low와 high로 전환이 이루어지는 매 시점마다 프로세서 실행

## SEQ 단계 구현

* 어떻게 제어로직 블럭들이 인스트럭션에 대한 계산 요구 사항과 연관 되는지 이해하라

* 선입 단계
	* PC를 주소로 10 Byte를 읽음
	* split block
		* 첫 바이트 주소는 두 개의 4 비트 값으로 나눠짐
		* icode 값에 따라 3가의 비트 신호를 계산
	* align 블럭
		* 1 번 바이트는 레지스터 지정자
			* 사용 안할 때 0xF로 설정
		* 레지스터 지정자와 상수 워드 설정
	* PC는 p + 1 + r + 8i
		* i = need_ valc
		* r = need_regids
* 해독과 재기록 단계
	* 모두 레지스터 파일에 접근 하기에 같이 설명
	* 각 포트는 한 개의 주소 연결과 데이터 연결을 모두 갖는다
		* 주소 연결은 레지스터 ID
		* 데이터 연결은 레지스터 파일의 출력 워드이거나 입력 워드로 사용
	* dstE,dstM,srcA,scrB 사용시 오퍼랜드 주의 할 것
* 실행 단계
	* valE 신호 = ALU 출력
	* ALU 계산 = valE 만드는게 포인트
* 메모리 단계
	* 프로그램 데이터를 읽거나 쓰는 일을 수전
	* 2개의 제어 블록으로 메모리 입력과 쓰기를 위한 값을 만든다
	* valM = 읽기 연산 수행 될 때 생성
	* valE, valA -> 메모리 읽기와 쓰기를 위한 주소
* PC 갱신 단계
	* 최종 단계는 새로운 PC 값 생성
	* icode 값에 따라 분기
