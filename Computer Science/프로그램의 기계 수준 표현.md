일반적인 원리는 이해해도 자세한 내용은 바우고 싶지않다는 말은 자신을 속이는 것이다 기억하자

## 역사점 관점

* 프로세서의 역사에서 각각의 인접한 프로세서는 이전 버전과 호환성을 갖도록 설계가 되었다
	*이전의 모든 버전에서 컴파일한 코드가 모두 실행 가능하다
	
이러한 프로세서의 발전 때문에 많은 이상한 잔재들이 남아있다. 역사를 보아야 이해가 되는 것들이 생긴 것이다

## 프로그램의 인코딩

* gcc(c 언어 컴파일러)에서 -0g 옵션의 기능
	* 최적화된 코드 생성
	* 최적화 수준이 올라가고 프로그램 속도도 증가
	* 기계어 코드와 본래 소스 코드 간의 관계를 이해하기 어려움
	* 컴파일 시간 증가 및 디버깅 도구 실행의 어려움

### 기계 수준 코드

* 기게 수준 프로그래밍에서 중요한 추상화
	* ISA
		* 기계 수준 프로그래밍의 형식과 동작 정리
		* instruction aet architecture
		* 인스트럭션이 순차적으로 실행되는 것 같은 추상화 제공
	* 기계 수준 프로그래밍은 가상 주소를 사용
		* 메모리가 엄청 큰 바이트 배열처럼, 메모리 모델 제공

컴파일러는 전체 컴파일 순서에서 C에서 제공하는 추상화된 실행 모델로 표현된 프로그램을 기초적인 인스트럭션들오 변환하는 일을 한다

어셈블리어 코드가 기계어 코드와 다른 점은 바이너리 기계 코드와 비교했을 때 더 읽기 쉬운 텍스트 형식이란 것이다

* 프로세서가 사용하는 주요 요소들
	* PC
		* 실행할 다음 인스트럭션의 메모리 주소를 가리킨다
	* 정수 레지스터 파일
		* 64 bit 값을 저장하기 위한 16개의 이름을 붙인 위치를 갖는다
		* 주소, 정수 데이터, 프로그램의 상태 추적
	* 조건 코드 레지스터
		* 가장 최근이 실행한 산술, 논리 인스트럭션이 관한 상태 정보 저장
		* 조건문, 반복문을 구현할 때 필요한 제어나 조건에 따른 데이터 흐름 변경을 위해
	* 벡터 레지스터
		* 하나 이상의 정수나 부동소수점 값들 저장

* 기계어 코드의 입장
	* 메모리 = 바이트 주소 지정이 가능한 큰 배열
	* 데이터 타입을 구분 안함
	* 연결된 데이터 타입은 연속된 바이트로 바라본다

* 프로그램 메모리 가지는 것들
	* 실행 기계어 코드
	* 운영체제를 위한 정보
	* 프로사저 호출과 기턴 관리하는 런타임 스택
	* 사용자이 의해 할당된 메모리 블럭
	
	
하마의 기계어 인스트럭션은 매우 기초적인 동작만을 수행한다

### 코드 예제

* 컴퓨터에 의해 실행된 프로그램은 단순한 일련의 인스터럭션을 인코딩한 일련의 바이트라 여겨짐
* 컴퓨터는 소스 코드에 대한 정보가 거의 없다


* objdump -d [목적파일]
	* 유닉스에서 역 어셈블러 명령어

* 기계어 코드의 특징
	* 자주 사용되는 인스터럭션들과 오퍼렌드는 짧른 길이를, 그 반대의 경우 길다
	* 인스트럭션 형식은 주어진 시작 위치에서부터 바이트들을 유일하게 디코딩한다
	* 역 어셈블러는 기계어 코드 파일의 바이트 순서에만 전적으로 의존한다

### 형식에 대한 설명

```assembly
	.file
	.text
	.global	multstore
multstore:
	pushq	%rbx
	movq	%rdx %rbx
	...
	ret
```

* '.'으로 시작하는 모든 것은 어셈블러와 링커에 지시하기 위한 디렉티브들이다
	* 무시하도 된다
	* 어셈블리 코드를 깔끔하게 하기위해 생략해도된다
* 일반적으로는 위와 같이 어셈블리어를 적고 인스트럭션 옆에 주석으로 인스트럭션의 기능을 적는게 정형화된 방식이다

## 데이터의 형식

인텔 프로세서들은 근본적으로 16비트 구조에서 32비트로 확장했다

그렇기에 인텔에서 워드는 16비트 데이터 타입을 의미한다

gcc가 생성한 대부분의 어셈블리 코드 인스터력션들은 오퍼랜드의 크기를 나타내는 단일 문자 접미어를 가지고 있다

mov 뒤에 붙는 b w l q가 그것들이다.

1. movb(바이트 이동)
2. movw(워드 이동)
3. movl(더블워드 이동)
4. movq(쿼드워드 이동)

## 정보 접근하기

x86-64 주처리장치 CPU는 64비트 값을 저장하는 16개의 범용레지스터를 가지고 있다 이들 레지스터는 정수디이터와 포인터를 저장하는데 쓰인다

인스트럭션들은 16개의 레지스터 하위 바이트들에 저장된 다양한 크기의 데이터에 대해 연산할 수 있다

* 바이트 수준 연산은 바이트 연산에 접근
* 16비트 연산은 2바이트에 접근
* 32비트 연산은 4바이트에 접근
* 64비트 연산은 8바이트에 접근

일반적인 프로그램은 서로 다른 레지스터들을 서로 다른 목적으로 이용한다 하지만 스택포인터 %rsp로 런타임 스택 끝을 가리킨다. 일부 인스트럭션들은 특별히 이 레지스터를 쓴다 

나머지 15개는 비교적 사용이 좀 더 자유롭다

중요한 것은 레지스터는 표준 프로그래밍 관습에 따라 스택을 관리하고, 함수 인자를 넘기고, 함수 값을 리천, 로컬 임시 데이터를 저장한다

### 오퍼랜드 식별자

대부분의 인스트럭션은 하나 이상의 오퍼랜드를 가진다

* 오퍼랜드
	* 연산을 수행할 source
	* 결과를 저장할 목적지(destination)을 저장한다

source는 상수로 주어지거나 레지스터나 메모리로부터 읽는다

결과값은 레지스터나 메모리에 저장된다

* 오퍼랜드의 종류는 3 가지 타입으로 구분할 수 있다
	* immediate : 상수 값 의미
		* ATT 형식의 어셈블리 코드에서는 $로 표시
	* register : 레지스터의 내용
		* 16개의 64비트, 32비트,16비트,8비트 레지스터릐 하위 일부분인 8,4,2,1 바이트 중 하나의 레지스터를 가리킨다
	* 메모리 참조
		* 유효주소에 의해 메모리 위치에 접근한다

* 기본 레지스터와 인덱스 레지스터는 모두 64 비트이다.
	* 기본이 64비트 크기의 레지스터를 사용하기 때문
	* 인덱스 레지스터는 메모리 주소랑 관련있다

## 데이터 이동 인스트럭션

* 가장 많이 쓰이는 인스트럭션은 한 위치에서 다른 위치로 복사하는 명령이다

* 인스트럭션 클래스
	* 여러 개 인스트럭션을 모아  동일한 동작을 다른 오퍼랜드 크기를 사용하여 수행한다
	* 이 덕에 대이터 이동 인스트럭션이 간단해졌다

* 소스 오퍼랜드는 상수, 레지스터 저장 값, 메모리 저장 값을 표시한다
* 목적 오퍼랜드는 레지스터, 메모리 주소 위치를 지정

x86은 데이터 이동 인스트럭션에서 두 개의 오퍼랜드 모두가 메모리 위치에 올 수 없도록 제한하고 있다

하나의 메모리 위치에서 다른 위치로 어떤 값을 복사하기 위해서는 두 개의 인스트럭션이 필요하다

1. 소스 값을 레지스터에 적재하는 인스트럭션
2. 소스 레지스터의 값을 목적지에 쓸 인스트럭션

### 데이터 이동 명령어(클래스)

* MOV
	* 특정 오퍼랜드의 값을 지정된 메모리 위치에 업데이트

작은 소스의 값을 더 큰 목적지로 복사할 때는 아래의 명령어를 쓴다

* MOVS
	* 부호 있는 정수에 사용
	* 목적지에 남은 바이트들을 중요한 비트(1)로 채워준다
* MOVZ
	* 부호 없는 정수에 사용
	* 목적지에 남은 바이트들을 모두 0으로 채워준다


### 인스트럭션 사용법

```assembly
movl $0x4050, %eax
movw %bp, %sp
...
``` 

* 인스트럭션 - 소스 오퍼랜드 - 목적 오퍼랜드 순으로 나열된다
* 두 개의 오퍼랜드가 동시에 메모리 위치에 접근 못한다
* 상수, 레지스터, 메모리가 오퍼랜드 위치에 나타난다(메모리-메모리는 안된다)
* 레지스터의 크기는 인스트럭션의 마지막 문자가 나타내는 크기와 일치해야한다


### 데이터 이동 예제

* C언어에서 포인터라고 부르는 것이 어셈블리어에서는 단순히 주소이다
	* 포인터를 역참조하는 것은 포인터를 레지스터에 복사하고, 이 레지스터를 메모리에 참조에 사용하는 과정으로 이루어진다
* 지연 변수들은 메모리에 저장되기보다는 종종 렞스터에 저장된다
	* 레지스터의 접근은 메모리보다 속도가 훨씬 빠르다

### 스택데이터의 저장과 추출(Push, Pop)

* 스택은 프로시져 호출을 처리하는데 중요한 역할을 한다
* 스택은. 후입선출(last in first out)이다
* 스택의 탑(top) 원소는 모든 스택 원소 중 가장 낮은 주소를 갖는 형태이다
* 관련 인스트럭션으로는 pushq, popq가 있다
	* 한 개의 오퍼랜드를 사용한다
	* 추가할 소스 데이터, 추출을 위한 데이터 목적지

## 산술연산과 논리연산

* CPU는 인스트럭션 클래스에 따라 연산을 한다
	* 오퍼랜드의 길이에 따른 다양한 변형이 가능하다
* 연산들은 4개의 그룹으로 나누어짐자
	* 유효주소 적재
	* 단항
	* 이항
	* 쉬프트

### 유효주소 적재

* leaq는 유효 주소 적재 인스트럭션
	* 목적 오퍼랜드는 레지스터리다
	* 메모리를 참조하지 않는다
	* 첫 번째 오퍼랜드는 유효주소를 목적지에 복사
* 컴파일러는 실제 유효 주소계산과 무관할 때 leaq를 쓴다
	* 나름의 예외 처리인가

### 단항 및 이항 연산

* 단항 연산
	* Increment
	* Decrement
	* Negate
	* Complement

단한 연산은 하나의 오퍼랜드가 소스와 목적지로 동시에 사용되는 연산이다.

* 이항 연산
	* Add
	* Subtract
	* Multiply
	* Exclusive-OR
	* OR
	* AND

이항 연산에서는 두 번째 오퍼랜드는 소스이면서 목적지로 사용된다

### 쉬프트 연산

* SAL, SHL, SAR, SHR
* 쉬프트 명령어 - 쉬프트 크기(양) - 쉬프트 값(변수)
* 쉬프트 인스트럭션들은 쉬프트할 양을 즉시 값이나 단일 바이트 레지스터 %cl로 표시 할 수 있다
* 목적 오퍼랜드가 레지스터나 메모리 위치가 될 수 있다

우측 산술 쉬프트는 부호비트를 복사해서  우측부터 채운다. 나머지는 해당 방향부터 0을 채운다

### 특수 산술 연산

* oct word : 16 byte
* 아래의 인스트럭션들은 128bit 표현이다

* mulq(imulq) - source operand - %rax
	* mulq(imulq)는 위의 순서대로 인스터럭션을 실행한다
	* %rdx(상위 64bit) + %rax(하위 64bit )
* divq(idivq)
	* 피제수 : 128bit(%rdx + %rax)
	* 제수 : instruction operand
	* 몫은 %rax, %rdx는 나머지
* cqto
	* oct word로 변경
	* operand 없음
	* %rax 부호비트를 읽어 %rdx에 복사

## 제어문

* 기계어 코드의 인스트럭션들은 모두 순차적으로 실행된다
* 기계어 인스트럭션들의 실행 순서는 JUMP로 바꿀 수 있다

### 조건 코드

* CF
	* carry flag
	* 올림 발생한 것을 표시
	* 비부호형 연산에서 오버플로우 검출할 때 사용
* ZF
	* zero flag
	* 가장 최근 연산 결과가 0인 것을 표시
* SF
	* negetive
	* 가장 최근 연산이 음수를 생성한 것을 표시
* OF
	* overflow flag
	* 가장 최근 연산이 양수/음수의 2의 보수 오버플로우를 발생시킨 것을 표시

* 논리연산은 캐리와 오버플로우가 0으로 세팅된다
* 쉬프트 연산에서는 캐리 플라그가 쉬프트 되어 없어지는 마지막 비트로 설정된다
	* 오버플로우 플래그는 0이다
* INC,DEC 인스트럭션들은 오버플로우와 영 플래그를 세팅하지만, 캐리 플래그는 영향을 주지 않는다

#### CMP , TEST

* 다른 레지스터들은 변경시키지 않으면서 조건 코드만 변경해 주는 인스트럭션이다

* CMP 인스트럭션
	* 두 오퍼랜드의 차에 따라 조건 코드를 설정한다
	* 목적지를 갱신하지 않고 조건 코드를 설정
		* 위의 조건을 제외하면 SUB 인스트럭션과 같이 동작한다
* TEST 인스트럭션
	* 목적지를 갱신하지 않고 조건 코드를 설정
		* 위의 조건을 제외하면 AND 인스트럭션과 같이 동작한다
