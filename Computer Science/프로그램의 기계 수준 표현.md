일반적인 원리는 이해해도 자세한 내용은 바우고 싶지않다는 말은 자신을 속이는 것이다 기억하자

## 역사점 관점

* 프로세서의 역사에서 각각의 인접한 프로세서는 이전 버전과 호환성을 갖도록 설계가 되었다
	*이전의 모든 버전에서 컴파일한 코드가 모두 실행 가능하다
	
이러한 프로세서의 발전 때문에 많은 이상한 잔재들이 남아있다. 역사를 보아야 이해가 되는 것들이 생긴 것이다

## 프로그램의 인코딩

* gcc(c 언어 컴파일러)에서 -0g 옵션의 기능
	* 최적화된 코드 생성
	* 최적화 수준이 올라가고 프로그램 속도도 증가
	* 기계어 코드와 본래 소스 코드 간의 관계를 이해하기 어려움
	* 컴파일 시간 증가 및 디버깅 도구 실행의 어려움

### 기계 수준 코드

* 기게 수준 프로그래밍에서 중요한 추상화
	* ISA
		* 기계 수준 프로그래밍의 형식과 동작 정리
		* instruction aet architecture
		* 인스트럭션이 순차적으로 실행되는 것 같은 추상화 제공
	* 기계 수준 프로그래밍은 가상 주소를 사용
		* 메모리가 엄청 큰 바이트 배열처럼, 메모리 모델 제공

컴파일러는 전체 컴파일 순서에서 C에서 제공하는 추상화된 실행 모델로 표현된 프로그램을 기초적인 인스트럭션들오 변환하는 일을 한다

어셈블리어 코드가 기계어 코드와 다른 점은 바이너리 기계 코드와 비교했을 때 더 읽기 쉬운 텍스트 형식이란 것이다

* 프로세서가 사용하는 주요 요소들
	* PC
		* 실행할 다음 인스트럭션의 메모리 주소를 가리킨다
	* 정수 레지스터 파일
		* 64 bit 값을 저장하기 위한 16개의 이름을 붙인 위치를 갖는다
		* 주소, 정수 데이터, 프로그램의 상태 추적
	* 조건 코드 레지스터
		* 가장 최근이 실행한 산술, 논리 인스트럭션이 관한 상태 정보 저장
		* 조건문, 반복문을 구현할 때 필요한 제어나 조건에 따른 데이터 흐름 변경을 위해
	* 벡터 레지스터
		* 하나 이상의 정수나 부동소수점 값들 저장

* 기계어 코드의 입장
	* 메모리 = 바이트 주소 지정이 가능한 큰 배열
	* 데이터 타입을 구분 안함
	* 연결된 데이터 타입은 연속된 바이트로 바라본다

* 프로그램 메모리 가지는 것들
	* 실행 기계어 코드
	* 운영체제를 위한 정보
	* 프로사저 호출과 기턴 관리하는 런타임 스택
	* 사용자이 의해 할당된 메모리 블럭
	
	
하마의 기계어 인스트럭션은 매우 기초적인 동작만을 수행한다

### 코드 예제

* 컴퓨터에 의해 실행된 프로그램은 단순한 일련의 인스터럭션을 인코딩한 일련의 바이트라 여겨짐
* 컴퓨터는 소스 코드에 대한 정보가 거의 없다


* objdump -d [목적파일]
	* 유닉스에서 역 어셈블러 명령어

* 기계어 코드의 특징
	* 자주 사용되는 인스터럭션들과 오퍼렌드는 짧른 길이를, 그 반대의 경우 길다
	* 인스트럭션 형식은 주어진 시작 위치에서부터 바이트들을 유일하게 디코딩한다
	* 역 어셈블러는 기계어 코드 파일의 바이트 순서에만 전적으로 의존한다

### 형식에 대한 설명

```assembly
	.file
	.text
	.global	multstore
multstore:
	pushq	%rbx
	movq	%rdx %rbx
	...
	ret
```

* '.'으로 시작하는 모든 것은 어셈블러와 링커에 지시하기 위한 디렉티브들이다
	* 무시하도 된다
	* 어셈블리 코드를 깔끔하게 하기위해 생략해도된다
* 일반적으로는 위와 같이 어셈블리어를 적고 인스트럭션 옆에 주석으로 인스트럭션의 기능을 적는게 정형화된 방식이다

