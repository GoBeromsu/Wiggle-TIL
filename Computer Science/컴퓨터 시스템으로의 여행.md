## 정보는 bit와 context로 이루어져 있다.

* 정보 = bit + context
* bit = data를 구성한다
	* 8bit가 1byte이며 1byte가 프로그램의 텍스트 문자를 나타낸다
	* 대부분의 컴퓨터는 ASKII코드를 사용하는데 ASKII 코드는 각 문자를 바이트 길이의 정수로 저장한다
	* 텍스트 파일 = 문자들의 모임 = 바이트의 모임 = 010010100 같은 비트의 모임이다
## 프로그래은 다른 프로그램에 의해 다른 형태로 변역된다

C언어를 예시로 들면 컴파일 시스템을 거쳐 실행파일로 변환된다

* 전처리
	* (C언어) #문자로 시작하는 디렉티브 따라 수정한다
		* #include로 해더파일을 코드에 추가한다
		* 그 결과 .i로 시작하는 새 C프로그램이 생긴다
	* 다른 언어는?
* 컴파일
	* (C언어) .i파일을 .s파일로 번역한다
	* 어셈블리어로 번역한다(텍스트 수준, 저수준 기계어)
* 어셈블리
	* .s파일을 기계어 인스트럭션으로 번역한다
	* 그 결과를 _재배치가능_ 목적프로그램 형태로 묶어 hello.o라는 목적프로그램 생성
	* 바이너리 파일이다
* 링크
	* 이미 컴파일된 함수(printf 등,printf.o로 존재) 파일들을 컴파일한 목적 프로그램과 링크를 형성한다
	* 그 결과 실행가는한 목적 프로그램을 생성한다
		* 생성된 실행가는한 목적 파일을 실행파일이라 하며 메모리에 적재해 실행시킨다

## 프로세스는 메모리에 저장된 인스트럭션을 읽고 해석한다

유닉스 시스템의 쉘에서 실행시키는 상황을 가정한다. 쉘은 실행파일의 이름이 내장 쉘 명령어인지 판단한 한다. 내장 쉘 명령어가 아닐 경우 실행파일로 판단하고 쉘은 실행 파일을 로딩 - 실행 - 종료 후 대기 상태가 된다

```shell
if 실행 파일 name is 내장 쉘 명령어
	run shell 명령어
else
	load 실행 파일
	run 실행 파일
```

* 왜 소제목이 위와 같을까?

hello 파일을 쉘에서 실행시키는 과정에서 쉘(응용프로그램)이 메모리에 저장된 실행파일을 로딩하는 것을 예시로 든거 같다.
### 시스템의 하드웨어 조직

일반적인 시스템은 CPU, ALU, PC ,USB로 이루어져 있다.

#### Bus

시스템 내를 관통하는 전기적 배선군을 bus(버스)라고 하며,  요소들 간에 바이트 정보를 전송한다.

일반적으로 word(워드)라는 고정 크기 바이트 단위로 데이터를 전송하도록 설계한다

한 개의 워드를 구성하는 바이트 수는 시스템마다 보유하는 __기본 시스템 변수__ 이다
 
 * 윈도우 32bit, 64bit에서 32와 64는 해당 운영체제에서 한 워드의 크기를 말한다 
 
#### 입출력 장치

시스템과 외부 세계와의 연결을 담당한다. 

* 각 입출력 장치는 입출력 버스와 컨트롤러나 어댑터를 통해 연결된다.
	* 컨트롤러는 디바이스 자체가 칩셋이거나 마더보드에 장착된다
	* 어댑터는 마더보드의 슬롯에 장착되는 카드이다
	* 이들의 목적은 입출력 버스와 입출력 장치들 간에 정보를 주고 받게 해주는 일이다
	
#### 메인 메모리

프로세서(중앙 처리장치)는  프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치이다.

* 물리적 : DRAM으로 이루어져있다.
* 논리적 : 연속적인 바이트들의 배열로 이루어져있다

#### 프로세서

CPU는 메인 메모리에 저장된 인스트럭션들을 해독(실행)하는 엔진이다

* 프로세서의 중심에는 워드 크기의 저장 장치 (레지스터)인 PC가 있다
	* PC는 메인 메모리의 기계어 인스트럭션을 가리킨다

시스템 전원 공급부터 끊어질 때까지 프로세서는 프로그램 카운터가 가리키는 곳의 인스트럭션을 반복 실행한다. 또한 다음 인스트럭션의 위치를 가리키도록 업데이트한다

* CPU 작업의 예
	* LOAD, STORE, OPERATE, JUMP
	* 덮어쓰기를 이용한다

## 캐시가 중요하다

즉 시스템에서 정보의 이동은 많은 시간을 요하는 것을 알게 되었다.

이 오버헤드(낭비되는 시간)을 줄이기 위해 캐시가 생겼다

* 캐시는 가능성을 저장한다
	* 다시 사용할 가능성이 높은 정보를 캐시에 저장한다
	* 프로세서와 캐시보다 더 크고 느린 장치 사이에 캐시 메모리를 끼어 넣는다

프로세서 - 메모리의 격차가 커짐에 따라 캐시의 중요성이 커지고 있다

뭔 말인고하니 반도체가 발달함에 따라 CPU의 읽는 속도가 훨씬 빨라졌다. 이 간극이 커져서 메모리를 더 빨리 동작하게 하느니 프로세서의 읽는 속도를 올리는게 더 효율적이다.

## 저장 장치들은 계층 구조를 이룬다

핵심은 저장 장치 사이에서 하위 레벨로 갈수록 가격이 낮아지고 크기가 커지며 느리지만 상위 레벨로 갈수록 가격이 비싸며 크기가 작아지고 빠르다

즉 캐시의 개념을 도입하면 상위 레벨의 저장장치는 하위레벨의 캐시가 될 수 있다

그 예시로 원격 네트워크 서버의 캐시로 로컬 컴퓨터의 하드디스크를 쓸 수 있다

## 운영체제는 하드웨어를 관리한다

응용프로그램은 다른 장치나 메인 메모리에 직접 접근하지 않는다 운영체제가 제공하는 서비스를 활용한다

운영체제는 하드웨어와 소프트웨어 사이를 제어한다

1. 제멋대로 동작하는 응용프로그램이 하드웨어를 잘못 사용하는 것을 막기 위해
2. 응용프로그램들이 단순하고 균일한 매커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어들으루조작할 수 있도록 하기 위함이다

위의 두 가지를 목표로 운영체제는 하드웨어와 소프트웨어를 추상화 하였다

원래는 소프트웨어[응용프로그램- 운영체제] + 하드웨어[프로세서 + 메인 메모리 + I/O 장치]이다

추상화 결과 아래와 같이 바뀌었다

1. 프로세스 = 프로세서 + 메인 메모리 + I/O 장치
2. 가상 메모리 = 메인 메모리 + I/O 장치
3. 파일 = I/O 장치

### 프로세스

프로세스는 실행 중인 프로그램에 대한 운영체제의 추상화이다.

즉 프로그램이 프로세서, 메인 메모리, 입출력 장치를 독점하는 것처럼 보이게한다. 다른 방해 없이 시스템 메모리의 유일한 객체인 것처럼 말이다

그래서 각각의 프로세스는 하드웨어를 배타적으로 사용하는 것처럼 느낀다.

하지만 __동시__ 라는 말은 한 프로세스의 인스트럭션들이 다른 프로세스의 인스트럭션들과 섞이는 것을 의미한다. 이를 위해 __문맥 전환__ 이란 방법을 사용한다

* 문맥 전환 
	* 현재 프로세스에서 다른 프로세스로 제어를 옮기려할 때 현재 프로세스의 컨텍스트를 저장하고 새 프로세스의 컨텍스트를 복원시키는 행위를 의미한다

프로세스의 전환은 운영체제의 커널에서 관리된다.
 커널은 운영체제 코드의 일부로 메모리에 상주한다. 커널으누별도의 프로새스가 아니다. 그저 모든 프로세스를 관리하기 위해 시스템이 이용하는 코드와 자료구조의 집합이다
 
### 쓰레드

프로세스가 위의 설명까지 읽으면 한 개의 제어흐름을 가지는 것처럼 생각할 수 있다.

최근엔 시스템에서 프로세스가 __쓰레드__ 라고 하는 다수의 실행 유닛으로 구성되어있다

각각의 쓰레드는 해당 프로세스의 컨텍스트에서 실행되며 동일한 코드와 전역 데이터를 공유한다.

쓰레드는 프로세스들에서보다 정보 공유가 쉽고 더 효율적이다

### 가상 메모리

가상 메모리는 각 프로세스들이 메인 메모리 전체를 독점적으로 사용하고 있는 것 같은 환상을 제공하는 추상화이다.

In linux
* 주소공간의 최상위 공간 : 모든 프로세스들이 공통으로 사용하는 운영체제의 코드와 데이터 저장
* 주소공간의  하위 공간 : 사용자 프로세스의 코드와 데이터 저장

* 커널 가상 메모리
	* 주소 공간의 맨 윗부분
	* 응용프로그램들은 이 영역을 읽고 쓰지 못함
	* 커널 코드 내의 함수 또한 직접 호출 금지, 필요시 커널 호출 필요
* 스택
	* 가상 메모리 공간의 맨 위에 컴파일러가 함수 호출을 구현하기 위해 사용함
	* 프로그램이 실행 되는 동안 동적으로 늘었다 줄었다함
	* 함수 호출시 커지고, 리턴시 줄어든다

### 파일

그저 연속된 바이트들이다. 모든 입출력 장치는 파일로 모델링한다. 

* 유닉스 I/O라는 시스템 콜들을 이용해 모든 입출력을 담당하고, 파일을 읽고 쓰는 형태로 이루어진다
* 간단한데 강력한 개념(연속적인 바이트)이라 다양한 입출력 장치에 통일된 뷰를 제공한다

## 시스템은 네트워크를 사용하여 다른 시스템과 통신한다


