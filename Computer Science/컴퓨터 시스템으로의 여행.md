## 정보는 bit와 context로 이루어져 있다.

* 정보 = bit + context
* bit = data를 구성한다
	* 8bit가 1byte이며 1byte가 프로그램의 텍스트 문자를 나타낸다
	* 대부분의 컴퓨터는 ASKII코드를 사용하는데 ASKII 코드는 각 문자를 바이트 길이의 정수로 저장한다
	* 텍스트 파일 = 문자들의 모임 = 바이트의 모임 = 010010100 같은 비트의 모임이다
## 프로그래은 다른 프로그램에 의해 다른 형태로 변역된다

C언어를 예시로 들면 컴파일 시스템을 거쳐 실행파일로 변환된다

* 전처리
	* (C언어) #문자로 시작하는 디렉티브 따라 수정한다
		* #include로 해더파일을 코드에 추가한다
		* 그 결과 .i로 시작하는 새 C프로그램이 생긴다
	* 다른 언어는?
* 컴파일
	* (C언어) .i파일을 .s파일로 번역한다
	* 어셈블리어로 번역한다(텍스트 수준, 저수준 기계어)
* 어셈블리
	* .s파일을 기계어 인스트럭션으로 번역한다
	* 그 결과를 _재배치가능_ 목적프로그램 형태로 묶어 hello.o라는 목적프로그램 생성
	* 바이너리 파일이다
* 링크
	* 이미 컴파일된 함수(printf 등,printf.o로 존재) 파일들을 컴파일한 목적 프로그램과 링크를 형성한다
	* 그 결과 실행가는한 목적 프로그램을 생성한다
		* 생성된 실행가는한 목적 파일을 실행파일이라 하며 메모리에 적재해 실행시킨다

## 프로세스는 메모리에 저장된 인스트럭션을 읽고 해석한다

유닉스 시스템의 쉘에서 실행시키는 상황을 가정한다. 쉘은 실행파일의 이름이 내장 쉘 명령어인지 판단한 한다. 내장 쉘 명령어가 아닐 경우 실행파일로 판단하고 쉘은 실행 파일을 로딩 - 실행 - 종료 후 대기 상태가 된다

```shell
if 실행 파일 name is 내장 쉘 명령어
	run shell 명령어
else
	load 실행 파일
	run 실행 파일
```

* 왜 소제목이 위와 같을까?

hello 파일을 쉘에서 실행시키는 과정에서 쉘(응용프로그램)이 메모리에 저장된 실행파일을 로딩하는 것을 예시로 든거 같다.
### 시스템의 하드웨어 조직

일반적인 시스템은 CPU, ALU, PC ,USB로 이루어져 있다.

#### Bus

시스템 내를 관통하는 전기적 배선군을 bus(버스)라고 하며,  요소들 간에 바이트 정보를 전송한다.

일반적으로 word(워드)라는 고정 크기 바이트 단위로 데이터를 전송하도록 설계한다

한 개의 워드를 구성하는 바이트 수는 시스템마다 보유하는 __기본 시스템 변수__ 이다
 
 * 윈도우 32bit, 64bit에서 32와 64는 해당 운영체제에서 한 워드의 크기를 말한다 
 
#### 입출력 장치

시스템과 외부 세계와의 연결을 담당한다. 

* 각 입출력 장치는 입출력 버스와 컨트롤러나 어댑터를 통해 연결된다.
	* 컨트롤러는 디바이스 자체가 칩셋이거나 마더보드에 장착된다
	* 어댑터는 마더보드의 슬롯에 장착되는 카드이다
	* 이들의 목적은 입출력 버스와 입출력 장치들 간에 정보를 주고 받게 해주는 일이다
	
#### 메인 메모리

프로세서(중앙 처리장치)는  프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치이다.

* 물리적 : DRAM으로 이루어져있다.
* 논리적 : 연속적인 바이트들의 배열로 이루어져있다

#### 프로세서

CPU는 메인 메모리에 저장된 인스트럭션들을 해독(실행)하는 엔진이다

* 프로세서의 중심에는 워드 크기의 저장 장치 (레지스터)인 PC가 있다
	* PC는 메인 메모리의 기계어 인스트럭션을 가리킨다

시스템 전원 공급부터 끊어질 때까지 프로세서는 프로그램 카운터가 가리키는 곳의 인스트럭션을 반복 실행한다. 또한 다음 인스트럭션의 위치를 가리키도록 업데이트한다

* CPU 작업의 예
	* LOAD, STORE, OPERATE, JUMP
	* 덮어쓰기를 이용한다

## 캐시가 중요하다

즉 시스템에서 정보의 이동은 많은 시간을 요하는 것을 알게 되었다.

이 오버헤드(낭비되는 시간)을 줄이기 위해 캐시가 생겼다

* 캐시는 가능성을 저장한다
	* 다시 사용할 가능성이 높은 정보를 캐시에 저장한다
	* 프로세서와 캐시보다 더 크고 느린 장치 사이에 캐시 메모리를 끼어 넣는다

프로세서 - 메모리의 격차가 커짐에 따라 캐시의 중요성이 커지고 있다

뭔 말인고하니 반도체가 발달함에 따라 CPU의 읽는 속도가 훨씬 빨라졌다. 이 간극이 커져서 메모리를 더 빨리 동작하게 하느니 프로세서의 읽는 속도를 올리는게 더 효율적이다.

## 저장 장치들은 계층 구조를 이룬다
