## 정보는 bit와 context로 이루어져 있다.

* 정보 = bit + context
* bit = data를 구성한다
	* 8bit가 1byte이며 1byte가 프로그램의 텍스트 문자를 나타낸다
	* 대부분의 컴퓨터는 ASKII코드를 사용하는데 ASKII 코드는 각 문자를 바이트 길이의 정수로 저장한다
	* 텍스트 파일 = 문자들의 모임 = 바이트의 모임 = 010010100 같은 비트의 모임이다
## 프로그래은 다른 프로그램에 의해 다른 형태로 변역된다

C언어를 예시로 들면 컴파일 시스템을 거쳐 실행파일로 변환된다

* 전처리
	* (C언어) #문자로 시작하는 디렉티브 따라 수정한다
		* #include로 해더파일을 코드에 추가한다
		* 그 결과 .i로 시작하는 새 C프로그램이 생긴다
	* 다른 언어는?
* 컴파일
	* (C언어) .i파일을 .s파일로 번역한다
	* 어셈블리어로 번역한다(텍스트 수준, 저수준 기계어)
* 어셈블리
	* .s파일을 기계어 인스트럭션으로 번역한다
	* 그 결과를 _재배치가능_ 목적프로그램 형태로 묶어 hello.o라는 목적프로그램 생성
	* 바이너리 파일이다
* 링크
	* 이미 컴파일된 함수(printf 등,printf.o로 존재) 파일들을 컴파일한 목적 프로그램과 링크를 형성한다
	* 그 결과 실행가는한 목적 프로그램을 생성한다
		* 생성된 실행가는한 목적 파일을 실행파일이라 하며 메모리에 적재해 실행시킨다

## 프로세스는 메모리에 저장된 인스트럭션을 읽고 해석한다

유닉스 시스템의 쉘에서 실행시키는 상황을 가정한다. 쉘은 실행파일의 이름이 내장 쉘 명령어인지 판단한 한다. 내장 쉘 명령어가 아닐 경우 실행파일로 판단하고 쉘은 실행 파일을 로딩 - 실행 - 종료 후 대기 상태가 된다

```shell
if 실행 파일 name is 내장 쉘 명령어
	run shell 명령어
else
	load 실행 파일
	run 실행 파일
```

* 왜 소제목이 위와 같을까?

hello 파일을 쉘에서 실행시키는 과정에서 쉘(응용프로그램)이 메모리에 저장된 실행파일을 로딩하는 것을 예시로 든거 같다.
### 시스템의 하드웨어 조직

일반적인 시스템은 CPU, ALU, PC ,USB로 이루어져 있다.

#### Bus

시스템 내를 관통하는 전기적 배선군을 bus(버스)라고 하며,  요소들 간에 바이트 정보를 전송한다.

일반적으로 word(워드)라는 고정 크기 바이트 단위로 데이터를 전송하도록 설계한다

한 개의 워드를 구성하는 바이트 수는 시스템마다 보유하는 __기본 시스템 변수__ 이다
 
 * 윈도우 32bit, 64bit에서 32와 64는 해당 운영체제에서 한 워드의 크기를 말한다 
 
#### 입출력 장치

시스템과 외부 세계와의 연결을 담당한다. 

* 각 입출력 장치는 입출력 버스와 컨트롤러나 어댑터를 통해 연결된다.
	* 컨트롤러는 디바이스 자체가 칩셋이거나 마더보드에 장착된다
	* 어댑터는 마더보드의 슬롯에 장착되는 카드이다
	* 이들의 목적은 입출력 버스와 입출력 장치들 간에 정보를 주고 받게 해주는 일이다
	
#### 메인 메모리

프로세서(중앙 처리장치)는  프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치이다.

* 물리적 : DRAM으로 이루어져있다.
* 논리적 : 연속적인 바이트들의 배열로 이루어져있다

#### 프로세서

CPU는 메인 메모리에 저장된 인스트럭션들을 해독(실행)하는 엔진이다

* 프로세서의 중심에는 워드 크기의 저장 장치 (레지스터)인 PC가 있다
	* PC는 메인 메모리의 기계어 인스트럭션을 가리킨다

시스템 전원 공급부터 끊어질 때까지 프로세서는 프로그램 카운터가 가리키는 곳의 인스트럭션을 반복 실행한다. 또한 다음 인스트럭션의 위치를 가리키도록 업데이트한다

* CPU 작업의 예
	* LOAD, STORE, OPERATE, JUMP
	* 덮어쓰기를 이용한다

## 캐시가 중요하다

즉 시스템에서 정보의 이동은 많은 시간을 요하는 것을 알게 되었다.

이 오버헤드(낭비되는 시간)을 줄이기 위해 캐시가 생겼다

* 캐시는 가능성을 저장한다
	* 다시 사용할 가능성이 높은 정보를 캐시에 저장한다
	* 프로세서와 캐시보다 더 크고 느린 장치 사이에 캐시 메모리를 끼어 넣는다

프로세서 - 메모리의 격차가 커짐에 따라 캐시의 중요성이 커지고 있다

뭔 말인고하니 반도체가 발달함에 따라 CPU의 읽는 속도가 훨씬 빨라졌다. 이 간극이 커져서 메모리를 더 빨리 동작하게 하느니 프로세서의 읽는 속도를 올리는게 더 효율적이다.

## 저장 장치들은 계층 구조를 이룬다

핵심은 저장 장치 사이에서 하위 레벨로 갈수록 가격이 낮아지고 크기가 커지며 느리지만 상위 레벨로 갈수록 가격이 비싸며 크기가 작아지고 빠르다

즉 캐시의 개념을 도입하면 상위 레벨의 저장장치는 하위레벨의 캐시가 될 수 있다

그 예시로 원격 네트워크 서버의 캐시로 로컬 컴퓨터의 하드디스크를 쓸 수 있다

## 운영체제는 하드웨어를 관리한다

응용프로그램은 다른 장치나 메인 메모리에 직접 접근하지 않는다 운영체제가 제공하는 서비스를 활용한다

운영체제는 하드웨어와 소프트웨어 사이를 제어한다

1. 제멋대로 동작하는 응용프로그램이 하드웨어를 잘못 사용하는 것을 막기 위해
2. 응용프로그램들이 단순하고 균일한 매커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어들으루조작할 수 있도록 하기 위함이다

위의 두 가지를 목표로 운영체제는 하드웨어와 소프트웨어를 추상화 하였다

원래는 소프트웨어[응용프로그램- 운영체제] + 하드웨어[프로세서 + 메인 메모리 + I/O 장치]이다

추상화 결과 아래와 같이 바뀌었다

1. 프로세스 = 프로세서 + 메인 메모리 + I/O 장치
2. 가상 메모리 = 메인 메모리 + I/O 장치
3. 파일 = I/O 장치

### 프로세스

프로세스는 실행 중인 프로그램에 대한 운영체제의 추상화이다.

즉 프로그램이 프로세서, 메인 메모리, 입출력 장치를 독점하는 것처럼 보이게한다. 다른 방해 없이 시스템 메모리의 유일한 객체인 것처럼 말이다

그래서 각각의 프로세스는 하드웨어를 배타적으로 사용하는 것처럼 느낀다.

하지만 __동시__ 라는 말은 한 프로세스의 인스트럭션들이 다른 프로세스의 인스트럭션들과 섞이는 것을 의미한다. 이를 위해 __문맥 전환__ 이란 방법을 사용한다

* 문맥 전환 
	* 현재 프로세스에서 다른 프로세스로 제어를 옮기려할 때 현재 프로세스의 컨텍스트를 저장하고 새 프로세스의 컨텍스트를 복원시키는 행위를 의미한다

프로세스의 전환은 운영체제의 커널에서 관리된다.
 커널은 운영체제 코드의 일부로 메모리에 상주한다. 커널으누별도의 프로새스가 아니다. 그저 모든 프로세스를 관리하기 위해 시스템이 이용하는 코드와 자료구조의 집합이다
 
### 쓰레드

프로세스가 위의 설명까지 읽으면 한 개의 제어흐름을 가지는 것처럼 생각할 수 있다.

최근엔 시스템에서 프로세스가 __쓰레드__ 라고 하는 다수의 실행 유닛으로 구성되어있다

각각의 쓰레드는 해당 프로세스의 컨텍스트에서 실행되며 동일한 코드와 전역 데이터를 공유한다.

쓰레드는 프로세스들에서보다 정보 공유가 쉽고 더 효율적이다

### 가상 메모리

가상 메모리는 각 프로세스들이 메인 메모리 전체를 독점적으로 사용하고 있는 것 같은 환상을 제공하는 추상화이다.

In linux
* 주소공간의 최상위 공간 : 모든 프로세스들이 공통으로 사용하는 운영체제의 코드와 데이터 저장
* 주소공간의  하위 공간 : 사용자 프로세스의 코드와 데이터 저장

* 커널 가상 메모리
	* 주소 공간의 맨 윗부분
	* 응용프로그램들은 이 영역을 읽고 쓰지 못함
	* 커널 코드 내의 함수 또한 직접 호출 금지, 필요시 커널 호출 필요
* 스택
	* 가상 메모리 공간의 맨 위에 컴파일러가 함수 호출을 구현하기 위해 사용함
	* 프로그램이 실행 되는 동안 동적으로 늘었다 줄었다함
	* 함수 호출시 커지고, 리턴시 줄어든다

### 파일

그저 연속된 바이트들이다. 모든 입출력 장치는 파일로 모델링한다. 

* 유닉스 I/O라는 시스템 콜들을 이용해 모든 입출력을 담당하고, 파일을 읽고 쓰는 형태로 이루어진다
* 간단한데 강력한 개념(연속적인 바이트)이라 다양한 입출력 장치에 통일된 뷰를 제공한다

## 시스템은 네트워크를 사용하여 다른 시스템과 통신한다

네트워크를 통해 다른 시스템들이 연결되는 것을 볼 수 있다. 이런 관점에서 네트워크 또한 __입출력 장치__ 라 볼 수 있다.

네트워크 사용의 예시라면 FTP, telnet 같은 응용 프로그램들이 있고 네트워크를 통한 정보 복사 기능을 이용한다

## 중요한 주제들

결국 핵심은 시스템은 단지 하드웨어 그 이상의 것이라는 것이다. 하드웨어와 소프트웨어가 서로 연결되어 응용프로그램 실행이란 목적을 달성하는게 아이디어이다. 더 빠르고 안정적이고 안전한 프로그램을 만들어보자

### 암달의 법칙

시스템 전체 성능 개선율 = 1/(1-시스템 개선에 필요한 시간 비율)+  시스템 개선에 필요한 시간/성능 개선 배수

즉 전체 시스템을 상당히 빠르게 하기위해서는 전체 시스템의 매우 큰 부분의 성능을 개선해야한다

암달의 법칙을 표현하는, 즉 개선하는 최상의 방법은 시간 비율의 형태로 나타내는 것이다

### 동시성과 병렬성

* 동시성
	* 다수의 동시에 벌어지는 일을 갖는 시스템에 관한 일반적인 개념
* 병렬성
	* 동시성을 사용해서 시스템을 보다 빠르게 동작하도록 하는 것을 말할 때 사용

#### 쓰레드 수준의 동시성

프로세스 추상화 개념을 이용하면 다수 프로그램이 동시에 실행되는 시스템을 생각할 수 있다.

쓰레드를 이용하면 한 프로세스 내에 다수의 제어흐름을 가질 수도 있다.

* 단일 프로세서 시스템
	* 한개의 프로세서를 가지고 프로세스들을 빠르게 전환해서 동시적으로 보이게함
* 멀티프로세서 시스템
	* 어느 시스템이 여러 개의 프로세서를 가지고 하나의 운영체제 커널의 제어 하에 동작하는 것

* 멀티쓰레딩(하이퍼 쓰레딩)
	* 하나의 CPU가 여러 개의 제어 흐름을 실행 할 수 있게 해주는 것
	* 매 사이클마다 실행할 쓰레드를 결정한다.
		* 즉 무슨 말인고하니 데이터를 로딩해야하는 상황에서 다음 사이클에는 다른 쓰레드를 실행시키며 효율을 뽑는다.

멀티프로세싱이 시스텡 성능을 개선하는 방법

1. 다수의 태스크를 실행할 때 동시성을 시뮬레이션할 필요를 줄여준다.
2. 프로그램이 병렬로 효율적인 멀티쓰레드 형태를 표현할 때 응용프로그램을 빠르게 실행할 수 있다.

#### 인스트럭션 수준 병렬성

최근에는 훨씬 낮은 수준에서의 추상화로 여러 개의 인스트럭션을 한 번에 실행할 수 있다. 이를 인스트럭션 수준의 병렬성이라고한다. 

프로세서는 다양한 기법을 이용해 여러 인스트럭션을 동시에 처리한다

그 예시로 파이프 라인 기법이 있다. 이는 하나의 인스트럭션을 실행하기 위해 요구되는 일들을 여러 단계로 나누고 프로세서 하드웨어가 일련의 단계로 구성되어 이들 단계를 하나씩 각각 수행한다

* 슈퍼스케일러
	* 사이클 당 한 개 이상의 인스트럭션을 실행할 수 있는 프로세서

#### 싱글 인스트럭션, 다중 데이터 병렬성(SIMD)

SIMD 병렬성 모드란 한 개의 인스트럭션이 다수의 연산을 수행할 수 있는 특수 하드웨어이다

SIMD 인스트럭션들은 대게 영상, 소리, 동영상 데이터 처리를 위한 응용프로그램 속도를 개선하기 위해 제공

#### 컴퓨터 시스템에서 추상화의 중요성

추상화는 프로그래머가 내부 동작을 고려하지 않고 코드를 사용할 수 있게 해준다. 그렇기에 중요하다

* 함수를 API 문서로 만들며 연습할 수 있다

