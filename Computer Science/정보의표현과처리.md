# 정보의 저장

대부분의 컴퓨터들은 메모리에서 주소지정이 가능한 최소단위 비트인 __바이트__ 를 사용한다

기계 수준 즉 하드웨어 수준에서 프로그램은 메모리를 가상 메모리라는 거대한 바이트 배열 취급한다

* 가상 주소 공간
	* 모든 가능한 주소들의 집합
	* 주소 : 각 바이트를 식별케한다

모든 프로세스는 가상 주소공간을 부여 받는다(메모리 공간이란 뜻은 아니다)

기계 수준의 프로그램은 각 프로그램의 객체를 바이트 블록, 프로그램 자신은 바이트의 연속으로 취급한다

### 16진수

이진수 표시는 너무 장황하고, 십진수 표시는 비트 패턴으로 변환해야하니 불편하다. 그래서 16진수가 채택되었다.

기계 수준 프로그램은 일반적으로 비트 패턴을 십진, 이진, 16 진수 간에 수동으로 변환한다.

### 데이터의 크기

* 모든 컴퓨터는 워드 크기를 규격으로 가진다.
	* 이는 포인터의 정규 크기를 표시한다

* 가상 주소공간의 최대 크기는 워드 크기에 의해 결정된다.
	* 하나의 가상 주소가 한 개의 워드로 인코딩된다.
	* x bit인 워드의 경우 가상 주소 공간은 2^x 바이트이다

이해를 돕자면 32bit 워드는 가상 주소 공간의 크기가 약 4 GB이다. 그래서 32bit 컴퓨터는 메모리를 최대 4GB까지 밖에 인식 못한다.

* 32비트 머신과 64비트 머신을 위한 프로그램을 만들 때 어떻게 컴파일되었는가가 핵심이다
	* 64비트 머신은 역변환 호환성을 가진다.


#### 프로그래머들은 그래서,,

* 고정된 정수형 크기를 이용하는 것이 프로그래머들이 데이터 표현을 안전하게 통제하는 방법이다
* 여러 종류의 컴퓨터와 컴파일러에서 동작할 수 있도록 노력해야한다

### 주소 지정과 바이트 순서

여러 바이트에 걸쳐 있는 프로그램 객체들을 다룰 때 우린 2가지 규칙을 써야한다

1. 객체의 주소가 무엇이 되어야하는지
2. 메모리에 바이트들은 어떻게 정렬해야 하는지

객체의 주소는 사용된 바이트의 최소 주소로 정한다

예를 들어 int 타입 변수 X가 주소 0x100을 가진다면 32bit 즉 4 바이트 크기의 X는 0x100,101.102,103에 저장될 것이다

바이트 정렬엔 두 가지 규칙이 있다

* 리틀 엔디안
	* 가장 덜 중요한 비트가 먼저 온다
	* 비트 표시시 가장 뒤에 있는 비트부터 저장
* 빅 엔디안
	* 가장 중요한 비트가 먼저 온다
	* 비트 표시시 가장 앞에 있는 비트부터 저장

바이트 정렬로 인한 문제가 있다. 컴파일된 프로그램은 동일한 결과를 출력하지만

1. 이진 데이터가 네트워크를 통해 다른 컴퓨터로 전송 될 때이다
2. 정수 데이터를 나타내는 바이트들을 살펴 볼 때이다
3. 정상적인 타입 체계를 회피하도록 작성 되었을 때
	* 굳이? 싶지만 시스템 수준 프로그램에서는 유용하고 필요하다
	
#### 알고가자 C언어

```c
typedef int *int_pointer;
int_pointer ip;
```

int_pointer의 타입은 int 포인터이다.
ip는 주소를 담을 것이다

### 스트링의 표시

각 문자들은 표준 인코딩에 따라 표시된다. 일반적으로 인코딩은 ASKII 문자코드이다. 

즉 문자의 주소는 16진수로 표시될 때 아스키코드 값을 따라간다

### 코드의 표현

같은 코드를 컴파일 후 기계어 코드를 보면 컴퓨터 타입에 따라 인스트럭션들의 인코딩이 다른 것을 알 수 있다.

결론 프로그램은 컴퓨터 관점에서 단순한 바이트의 연속일 뿐이다. 본래 소스 프로그램에 대한 정보를 전혀 가지고 있지 않다

### Boolean 대수

불린 대수란 이진수 값 0, 1을 논리값 True False초 인코딩하여 대수학을 수식화 할 수 있다.

### 논리연산

* ^ : OR
* & : AND
* | : EXCLUSIVE-OR
* ~ : NOT

## 정수의 표시

정수를 표시하는 방법에는 여러가지가 있다

* 양수만 표시하는 법
* 음수, 양수, 0 모드를 표시하는 방법

### 비 부호형 인코딩

* B2U(unsigned to binary)
	* 2^n 개의 데이터 저장(n은 비트 수)
	* 2^n - 1은 최대 크기
	* 전단사 특징을 갖고 있다
		* 값이 유일하다
				
### 2의 보수 인코딩

* B2Tw(2의 보수 인코딩)
	* 표현 범위 : -2^n ~ 2^n 
	* 첫 번째 비트로 음수 양수 판단
	* 전단사 특징을 가진다

* 가능한 표현의 수가 음수가 양수보다 1개 많다
	* 0 때문이다

### 비 부호형과 부호형간의 변환

핵심은 숫자 값은 변해도 비트 패턴은 변하지 않는다는 것이다

* 2의 보수 표현과 비부호형 간에 양방향으로 변환 효과를 얻을 수 있다
	* 양수 영역은 모두 동일한 영역을 차지한다.
	* U2T = u - 2^n
* 비부호형의 음수 영역이 부호형으로 변환 될 때 음수 영역이 부호형의 양수 영역에 포함된다.

### 수의 비트 표시 확장하기

* U2U(unsigned to unsigned)
	* 비부호형의 경우 단순히 앞에 0을 추가한다
		* 이를 0의 확장이라고 한다
* T2T(two's complement to two's complement)
	* 부호형의 경우 앞에 1을 추가한다

이렇게 확장을 하다보면 부호형과 비부호형 간의 변환 과정과  수의 확장 순서에 따라 값이 달라질 수 있으니 조심하도록
