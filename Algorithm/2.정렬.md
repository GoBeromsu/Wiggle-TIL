# 정렬
## 정렬 알고리즘

* Simple, low
  * bubble
  * insertion
  * seletion
* Fast
  * Quick sort
  * Merge sort
  * Heap sort
* Radix sort 

## Selection Sort

* 가장 큰 값을 계속 정렬하고픈 위치로 보냄
  * 모든 데이터 값에 대해 계속 반복한다
* 최악,최선,평균 시간 복잡도는 O(n^2)
  * for 루프는 n-1번 반복
  * 가장 큰 수를 찾기 위한 비교 횟수 
    * n-1,n-2,n-2 ... 2,1
    * 교환은 상수 작업임

## Bubble sort

* 실행 시간은 O(n^2)
* 1 회전마다 검색할 인덱스 값 범위 내에서 인접한 값의 크기를 비교해서 계속 바꿔 나간다
* 수행 시간 계산
  * for 루프는 n-1 번 반복
  * for 루프는 각각 n-1,n-2....2,1 번 반복
  * 교환은 상수 시간 작업

## Insertion Sort

* k-1이 미리 정렬되어 있는 상태에서 k 번째 인덱스를 추가했을 때도 정렬되게 하려면 어떻게 해야할까?
* 인덱스가 하나라면 정렬된 상태라 생각하자
* 인덱스가 2개 이상이 되었다.   
  * 그러면 작은 인덱스를 앞에 삽입하면 인덱스는 정렬된 상태가 된다

* 최악의 시간 복잡도는 O(n^2), 최선의 경우 O(n)이다.
  * 최악의 경우 자기 앞의 모든 인덱스와 비교를 해야한다.
  * 운이 좋다면 바로 비교를 끝낼 수 있다.
