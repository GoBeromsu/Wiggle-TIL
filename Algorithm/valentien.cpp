#include <stdio.h>
#include <time.h>
#include <iostream>
#include <Windows.h>
#pragma execution_character_set("utf-8")

using namespace std;

int getZeros(int n)
{   
    // num은 0이 몇개인지 센 값을 저장하는 변수입니다.
    int num = 0;
    // 가장 오른쪽 비트가 0인 동안만 반복문을 반복합니다
    // 0의 갯수를 구하기 위함입니다.
    while ((n & 1) == 0)
    {
        num++;
        // 0의 갯수를 1 추가한 후 n 값을 오른쪽으로 쉬프트하며 
        // 순차적으로 1이 있을 때까지 반복해 0을 구하는 것입니다.
        n >>= 1;
    }

    return num;
}

int main()
{
    // c++ 한글 깨짐 현상 방지를 위한 함수입니다
    SetConsoleOutputCP(65001);
    // start와 finish 변수에 함수 실행 시간과 종료 시간 후 차를 duration에 저장합니다.
    // duration : 프로그램 실행 시간
    clock_t start, finish;
    double duration;

    // 위 문제는 중복 조합을 이용하여 풀 수 있습니다.
    // 중복 조합의 경우 n Combination with repetition k = n+k-1 Combination 입니다
    // 아래 변수 n과 k는 중복 조합을 새로운 조합으로 표현하는데 사용합니다.
    // count는 초콜릿을 나누어 줄 수 있는 경우의 수를 카운트합니다.
    int N = 0, m = 0, K = 0;
    int n = 0, k = 0, count = 0;
    int bit;

    cin >> N >> m >> K;

    start = clock();
    // 초콜릿을 미리 나눠 줄 수 있으므로 K에서 나눠준 초콜릿 N*m 개를 미리 빼주어야 합니다.
    // 즉 k = K-N*m이고, 새로운 조합 n Combination k의 k가 됩니다.
    k = K - N * m;
    // 앞서 말했다시피 중복 조합을 조합으로 바꿀 때 n Combination with repetition k의 n은 n+k-1입니다.
    // 즉 미리 나눠주고 남은 초콜릿과 함께 계산하면 n = N+k-1입니다.
    n = N + k - 1;

    // 조합은 비트 마스크 방식으로 구할 것입니다
    // c++의 next_permutation이나 재귀로 간단히 구할 수 있지만 시간이 오래 걸리기 때문입니다.

    // bit는 탐색을 시작할 부분입니다.
    // (1<<k)-1은 n개에서 k개 선택 된 것들 중 비트 값이 가장 작은 값입니다.

    bit = (1 << k) - 1;
    // combination을 구하는 규칙이 있습니다.
    //  1. 맨 하위에서 연속되어 있는 1 비트들 중에서 상위 비트를 1칸 왼쪽으로 움직입니다.
    //  2. 움직인 비트보다 오른쪽에 있는 비트들은 오른쪽 끝으로 붙입니다.
    //  3. 모두 탐색했으면 빠져나옵니다. while (bit < (1 << n))
    // 3 Combintaion 2를 예시로 들어 보겠습니다.
    // 0 1 1 - 1 << 2는 100 이고, 1을 빼면, 011입니다.  
    //       - 이는 길이에 상관 없이 탐색을 시작할 때 k개가 선택 되었고, k개를 고르는 조합을 비트로 나타낸 값중에 가장 작음이 자명합니다.
    //       - 즉 반복문의 초기 값을 적당합니다.
    // 1 0 1 - 위의 말한 순서를 반복합니다.
    // 1 1 0 - 110을 2번까지 진행하면 1001입니다. 1001은 (1<<3)인1000보다 크므로 종료합니다.
    // 3 Combination 2의 경우의 수는 3개이며 011,101,110 임을 알 수 있습니다.
    while (bit < (1 << n))
    {
        // 경우의 수를 카운트해줍니다.
        // 완전 탐색이 아니라 다음 경우의 수를 구해서 움직이기 때문에 반복분의 반복 횟수는 경우의 수와 동일합니다.
        count += 1;
        // 조합에서 k가 0이면 경우의 수는 무조건 1이므로 연산을 줄이기 위해 k가 0이면 바로 반복문을 탈출합니다.
        if (k == 0)
        {
            
            break;
        }
        // temp는 최하위 1비트 뒤를 모두 1로 바꿉니다.
        // temp를 통해 최하위 1비트가 어디 있는지 알 수 있습니다.
        int temp = bit | ((bit & -bit) - 1);
        // temp에 1을 더하면 앞서 설명한 1번에 해당합니다. 
        // 맨 하위 연속 된 1 비트들 중에서 상위 비트를 1칸 왼쪽으로 옮긴 것입니다.

        // 그 다음 2번 규칙(움직인 비트보다 오른쪽에 있는 비트들은 오른쪽 끝으로 붙입니다)을 적용하겠습니다.
        // 2의 보수법을 활용해 (~temp & -~temp)하면 최하위 1의 위치를 알 수 있습니다.
        // (어떤 수를 2의 보수법으로 표현 후 원래 식과 AND 연산을 하면 최하위 비트 외에는 모두 0이 된다)
        // 그렇다면 (~temp & -~temp) - 1은 최하위 1 아래의 모든 수를 1로 바꾼 후 나머지는 0 이 됩니다.
        // 그 후 본래 값의 0의 갯수 + 1만큼 오른쪽으로 이동합니다.
        // 0의 갯수 +1을 하는 이유는 (~temp & -~temp) - 1에는 1번 규칙에서 옮긴 상위 비트 1을 안 옮긴 상태라 1이 남아있습니다.
        // 남은 1을 오른쪽으로 쉬프트 연산을 한 번 더해 처리해주는 것입니다.
        // 최종적으로 temp+1과 (((~temp & -~temp) - 1) >> (getZeros(bit) + 1))을 OR하면 다음 경우의 수가 나옵니다.
        bit = (temp + 1) | (((~temp & -~temp) - 1) >> (getZeros(bit) + 1));
    }

    finish = clock();
    // 출력
    duration = (double)(finish - start) / CLOCKS_PER_SEC;
    cout << count << endl;
    cout << "실행시간: " << duration << "초" << endl;

    return 0;
}