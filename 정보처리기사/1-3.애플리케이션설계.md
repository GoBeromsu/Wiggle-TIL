# 1-3.애플리케이션설계

## 소프트웨어 아키텍쳐 설계

- [ ]  소프트웨어 아키텍쳐
    - 소프트웨어 구성 요소 간의 관계를 표현하는 시스템의 구조 또는 구조체
    - 이해 관계자들의 의사소통 도구
    
    ### 기본 원리
    
    - [ ]  모듈화
    - [ ]  추상화
    - [ ]  단계적 분해
    - [ ]  정보 은닉
- [ ]  모듈화
    - 재사용성 향상
    - 시스템 기능을 모듈 단위로 나눈 것
- [ ]  추상화
    - 문제를 포괄적인 개념을 설계 후 차례로 세분화하며 구체화 하는 것
    - 최소 비용으로 상황 대처
    
    ### 추상화의 유형
    
    - [ ]  과정 추상화
    - [ ]  데이터 추상화
    - [ ]  제어 추상화
    - [ ]  단계적 분해
        - 하향식 설계 전략
        - 추상화의 반복에 의해 세분화
    - [ ]  정보 은닉
        - 한 모듈 내부 자료가 감추어져 다른 모듈이 접근이나 변경하지 못하는 기법
        - 필요한 정보만 인터페이스로 주고 받음
    - [ ]  소프트웨어 아키텍처의 품질 속성
        - [ ]  시스템 측면
        - [ ]  비즈니스 측면
        - [ ]  아키텍처 측면
    - [ ]  소프트웨어 아키텍처의 설계 과정
        1. 설계 목표 설정
        2. 시스템 타입 결정
        3. 아키텍처 패턴 적용
        4. 서브시스템 구체화
        5. 검토
    - [ ]  시스템 타입
        - 대화형 시스템
        - 이벤트 중심 시스템
        - 변화형 시스템
        - 객체 영속형 시스템
    - [ ]  협약에 의한 설계
        - 선행 조건
        - 결과 조건
        - 불변 조건

## 아키텍처 패턴

- [ ]  아키텍처를 설계할 때 참조하는 전형적인 해결 방식
    - [ ]  아키텍처 스타일 또는 표준 아키테처라고함
    
    ### 장점
    
    - [ ]  개발 시간 단축
    - [ ]  안정적인 개발 가능
    - [ ]  의사소통 간편
    - [ ]  개발에 참여하지 않은 사람도 손쉽게 유지 보수 가능
    - [ ]  시스템 특성을 개발 전 예측 가능
- [ ]  레이어 패턴
    - 특정 계층 만을 교체해 시스템 개선 가능
    - 상위 계층은 서비스 제공자, 하위 계층은 클라이언트
    - 마주 보는 두 개의 계층 사이에서만 상호작용 발생
- [ ]  클라이언트-서버 패턴
    - 하나의 서버와 다수의 클라이언트로 구성되는 패턴
    - 사용자는 클라이언트와 의사소통
    - 서버는 항시 대기 상태
    - 클라이언트와 서버는 동기화할 때 제외하고는 서로 독립적
- [ ]  파이프-필터 패턴
    - 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화해 파이프로 데이터 전송
    - 재사용 및 확장 용이
    - 데이터 변환, 버퍼링, 동기화 등에 주로 사용
    - 필터간 데이터 이동시 오버헤드 발생
- [ ]  MVC 패턴
    - 모델,뷰,컨트롤러로 구성
    - 각 컴포넌트는 서로 영향 받지 않고 개발 작업 수행 가능
    - 대화형 애플리케이션에 적합

### 기타 패턴

- [ ]  마스터-슬레이브 패턴
    - 마스터가 동일 구조의 슬레이브에게 작업 분할
    - 장애 허용 시스템과 병렬 컴퓨팅 시스템
- [ ]  브로커 패턴
    - 서비스와 특성을 브로커 컴포넌트 요청
    - 브로커가 컴포넌트와 사용자 연결
    - 분산 환경 시스템에 적절
- [ ]  피어-투-피어 패턴
    - 피어는 클라이언트와 서버가 될 수 있음
    - 전형적인 멀티스레딩 방식 사용
- [ ]  이벤트-버스 패턴
    - 소스 → 특정 채널에 이벤트 메시지 발행
    - 해당 채널 구독한 리스너들이 메시지 받아 이벤트 처리
    - 소스, 리스너, 채널, 버스로 구성
- [ ]  블랙보드 패턴
    - 모든 컴포넌트가 공유 데이터 저장소와 블랙포드 컴포넌트에 접근 가능
    - 검색을 통해 블랙보드에서 원하는 데이터 검색 가능
    - 해결이 명확하지 않은 문제에 적합
    - 음성 인식, 차량 식별, 신호 해석에 활용
- [ ]  인터 프리터 패턴
    - [ ]  프로그램 코드의 각 라인 수행 방법 지정
    - [ ]  기호마다 클래스를 갖도록 구성
    - [ ]  특정 언어로 작성된 프로그램 코드 해석하는 컴포넌트 설계 사용

## 객체지향

- [ ]  객체 지향
    - [ ]  구조적 기법의 문제점 해결위함
    - [ ]  소프트웨어의 재사용 및 확자 용이
    - [ ]  복잡한 문제를 단계적, 계층적 표현
    - [ ]  멀티미디어 데이터 및 병렬 처리 지원
- [ ]  객체
    - [ ]  데이터와 함수로 구성
    - [ ]  독립적 식별 가능
    - [ ]  시간에 따라 상태 변화
    - [ ]  객체와 객체는 상호 연관성에 의한 관계 형성
    - [ ]  객체가 반응할 수 있는 메시지의 집합 → 행위
- [ ]  클래스
    - [ ]  공통된 속성과 연산을 갖는 객체의 집합
    - [ ]  객체지향 프로그램에서 데이터 추상화의 단위
- [ ]  캡슐화
    - [ ]  데이터와 데이터를 처리하는 함수를 하나로 묶는 것
    - [ ]  인터페이스가 단순, 객체 간의 결합도가 낮아짐
- [ ]  상속
    - 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려 받는 것
- [ ]  다형성
    - 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 잇는 능력
- [ ]  연관성
    - [ ]  연관화 : is member of
    - [ ]  분류화 : is instance of
    - [ ]  집단화 : is part of
    - [ ]  일반화 : is a
    - [ ]  특수화/상세화 : is a

## 객체지향 분석 및 설계

- [ ]  클래스 식별이 주 목적
- [ ]  사용자의 요구사항 분석하여, 문제를 정의 및 분석
- [ ]  객체 지향 분석의 방법론
    - Rumbaugh(럼바우) 방법
        - [ ]  가장 일반적으로 사용
        - [ ]  분석 활동을 **객체 모델, 동적 모델, 기능 모델**로 나누어 수행
        - [ ]  객체 모델링 → 객체 다이어그램
        - [ ]  동적 모델링 → 상태 다이어그램
        - [ ]  기능 모델링 → 자료 흐름도(DFD)
    - Booch(부치) 방법
        - [ ]  미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법
    - Jacobson 방법
        - [ ]  Usecase를 강조하여 사용하는 분석 방법
    - Coad와 Yourdon 방법
        - [ ]  E-R 다이어그램으로 객체 모델링
    - Wirfs-Brock 방법
        - [ ]  분석과 설계 간의 구분이 없음
        - [ ]  고객 명세서를 평가해 설계 작업까지 연속 수행
- 객체지향 설계 원칙
    - [ ]  단일 책임원칙
        - 객체는 단 하나의 책임만 가져야함
        - 응집도는 높고, 결합도는 낮게 설계
    - [ ]  개방-폐쇄 원칙
        - 기존의 코드를 변경하지 않고 기능을 추가하도록 설계
        - 공통의 인터페이스를 하나의 인터 페이스로 묶어 캡슐화 하는 등
    - [ ]  리스코프 치환 원칙
        - 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야한다
        - 자식 클래스는 부모 클래스의 확장만 수행
            - 책임 무시하거나, 재정의하지 않음
    - [ ]  인터페이스 분리 원칙
        - 사용하지 않는 인터페이스와 의존 관계를 맺거나 연관 되지 않아야한다는 원칙
    - [ ]  의존 역전 원칙
        - 객체 간 의존 관계가 성립할 때 추상성이 본인보다 높은 클래스와 의존 관계를 맺어야함
        - 일반적으로 인터페이스를 활용하면 이 원칙은 준수된다

## 모듈

- 모듈
    - [ ]  단독으로 컴파일 가능
    - [ ]  모듈의 독립성은 결합도(Coupling)와 응집도(Cohesion)에 의해 측정
        - 모듈의 크기는 작게, 응집도는 높이고, 결합도는 약하게 만들어라!
- 결합도
    - [ ]  자료 → 스탬프 → 제어 → 외부 → 공통 → 내용
    - [ ]  자료 결합도
        - 모듈 간 인터페이스로 자료 요소만 구성
    - [ ]  스탬프 결합도
        - 모듈 간 인터페이스로 자료 구조 전달
    - [ ]  제어 결합도
        - 다른 모듈을 내부 논리적 흐름을 제어하기 위해 **제어 신호**를 이용
        - 권리 전도 현상 발생 (하위 모듈에서 상위 모듈로 제어 신호 이동)
    - [ ]  외부 결합도
        - 모듈 내에서 선언한 데이터를 외부 다른 모듈에서 참조
    - [ ]  공통(공유) 결합도
        - 공유되는 공통 데이터 영역을 여러 모듈이 사용함
    - [ ]  내용 결합도
        - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조 및 수정
- 응집도
    - [ ]  기능적 →  순차적 → 교환적 → 절차적 → 시간적 → 논리적 → 우연적
    - [ ]  기능적 응집도
        - 모듈 내부 모든 기능 요소들이 단일 문제와 연관되어 수행
    - [ ]  순차적 응집도
        - 모듈 내 활동으로 나온 출력 데이터를 그 다음 활동에서 입력 데이터로 사용하는 경우
    - [ ]  교환(통신)적 응집도
        - 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들로 구성
    - [ ]  절차적 응집도
        - 모듈이 다수의 기능을 가질 때 모듈 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
    - [ ]  시간적 응집도
        - 특정 시간에 처리 되는 기능을 모아 모듈을 만든 경우
    - [ ]  논리적 응집도
        - 유사 성격이나, 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우
    - [ ]  우연적 응집도
        - 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성됨
- [ ]  Fan In / Fan Out
    - 시스템 복잡도 파악 가능
    - 시스템 복잡도 최적화를 위해 팬인은 높게, 팬아웃은 낮게 설계
    - 팬인이 높으면 단일 장애 발생 가능
- [ ]  N-S 차트
    - 논리 기술 중점
    - 제어 논리구조 표현
    - GOTO나 화살표 사용하지 않음
    - 조건 복합되어 있는 곳 처리 식별에 적합
    - 작성이 어렵고, 임의로 제어를 전이하는 것이 불가능
    - 총체적 구조와 인터페이스 표현이 어려움

## 공통 모듈

- [ ]  공통 모듈
    - 정확성
    - 명확성
    - 완전성
    - 일관성
    - 추적성
- [ ]  재사용
    - 재사용 대상은 결합도는 낮고, 응집도는 높아야함
    - 재사용 규모에 따른 분류
        - 함수와 객체 : 클래스나 메소드 단위
        - 컴포넌트 : 컴포넌트 수정 없이 인터페이스를 통해 통신
        - 애플리케이션 : 공통된 기능들을 제공하는 애플리케이션 공유하는 방식
- 효과적인 모듈 설계 방안
    - [ ]  모듈의 제어 영역 안에 그 모듈의 영향 영역 유지
    - [ ]  예측 가능하고, 지나치게 제한적이어서는 안됨
    - [ ]  하나의 입구가 하나의 출구를 가지도록
    - [ ]  모듈 간의 계층적 관계를 정의하는 자료가 제시되어야함

## 코드

- [ ]  코드
    - 식별 기능
    - 분류 기능
    - 배열 기능
    - 표준화 기능
    - 간소화 기능
- 코드의 종류
    - [ ]  순차 코드
        - 일정 기준에 따라 순차적으로 일련 번호 부여
    - [ ]  블록 코드
        - 공통성 있는 것끼리 블록으로 구분
    - [ ]  10진 코드
        - 도서 분류식 코드
        - 10진 분할을 필요한 만큼 반복
    - [ ]  그룹 분류 코드
        - 일정 기준에 따라 대,중,소 분류하여 구분
        - 그룹 안에서 일련 번호 부여
    - [ ]  연상 코드
        - 코드화 대상과 관계있는 숫자나 문자 기호를 이용하여 코드 부여
    - [ ]  표의 숫자 코드
        - 코드화 대상의 물리적 수치를 그대로 코드에 적용
    - [ ]  합성 코드
        - 2개 이상의 코드를 섞어 만든다

## 디자인 패턴

- [ ]  디자인 패턴
    - 모듈 단위의 세부적인 구현 방안 설계시 참조하는 전형적 패턴
    - 생성, 구조, 행위 패턴으로 구성되어 있음
- [ ]  디자인 패턴의 장,단점
    - [ ]  범용적 코딩 스타일로 구조 파악 용이
    - [ ]  초기 투자 비용 부담
    - [ ]  설계 변경 요청에 유연한 대처 가능
    - [ ]  객체지향 기반이라 다른 기반의 애플리케이션 개발에는 적합하지 않음
- 생성 패턴
    - 객체 생성과 참조 과정을 캡슐화해, 프로그램 구조에 영향을 크게 받지 않도록함
        - [ ]  추상 팩토리
            - 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적 표현
            - 연관된 서브 클래스를 묶어 한 번에 교체 가능
        - [ ]  빌더
            - 작게 분리된 인스턴스를 조합하여 객체 생성
            - 객체 생성 과정과 표현 방법 분리
        - [ ]  팩토리 메소드
            - 객체 생성을 서브 클래스에서 처리하도록 분리한 캡슐화 패턴
            - 상위 클래스는 인터페이스 정의, 실제 생성은 서브 클래스 담당
            - 가상 생성자 패턴이라고도함
        - [ ]  프로토타입
            - 원본 객체를 복제하는 방법으로 객체 생성하는 패턴
            - 일반적인 방법으로 객체 생성, 비용이 클 경우 주로 사용
        - [ ]  싱글톤
            - 하나의 객체를 생성하여 어디서든 참조, 동시 참조는 불가능
            - 불필요한 메모리 낭비 최소화
- 구조 패턴
    - 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴
    - [ ]  어댑터
        - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환
        - 기존 클래스를 이용하고 싶은데 인터페이스가 일치하지 않을시 사용
    - [ ]  브리지
        - 구현부에서 추상층 분리해 서로 독립정 확장 지원
        - 기능과구현을 두 개의 별도 클래스로 구현
    - [ ]  컴포지트
        - 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용
    - [ ]  데코레이터
        - 객체 간의 결합을 통해 능동적으로 기능 확장 가능
        - 다른 객체들을 덧붙이는 방식으로 구현
    - [ ]  퍼싸드
        - 복잡한 서브 클래스들을 피해 상위에 인터페이스 구성
            - 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
        - Wrapper 객체 필요
            - 서브 클래스들 사이의 통합 인터페이스 제공함
    - [ ]  플라이웨이트
        - 인스턴스를 가능한 공유해서 사용함으로써 메모리 절약하는 패턴
        - 다수 유사 객체 생성하거나 조작할 때 유용하게 사용
    - [ ]  프록시
        - 접근이 어려운 객체와 연결하려는 객체 사이에 인터페이스 역할을 수행하는 패턴
        - 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용
- 행위 패턴
    - 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴
        - [ ]  책임 연쇄
            - 요청 처리 객체가 둘 이상이라 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태
            - 요청 처리하는 각 객체들이 고리로 묶여 있음
        - [ ]  커맨드
            - 요청을 객체의 형태로 캡슐화해 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
            - 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리
        - [ ]  인터프리터
            - 언어에 문법 표현을 정의하는 패턴
            - SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용
        - [ ]  반복자
            - 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
            - 내부 표현 방법의 노출 없이 순차적인 접근 가능
        - [ ]  중재자
            - 객체들 간의 복잡한 상호착용을 캡슐화하여 객체로 정의하는 패턴
            - 객체 사이의 의존성을 줄여 결합도 감소
            - 중재자는 객체 간의 통제와 지시의 역할 수행
        - [ ]  메멘토
            - 특정 시점에서의 객체 내부 상태를 객체화
            - 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능 패턴
        - [ ]  옵저버
            - 한 객체의 상태가 변하면 객체에 상속된 다른 객체들에게 변화된 상태 전달하는 패턴
            - 분산된 시스템 간에 이벤트를 생성, 발행하고, 이를 수신해야 할 때 사용
        - [ ]  상태
            - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
            - 객체 상태 캡슐화하고, 이를 참조하는 방식으로 처리
        - [ ]  전략
            - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환가능하게함
            - 클라이언트에 영향 없이 알고리즘 변경 가능
        - [ ]  템플릿 메소드
            - 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 패턴
            - 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에게 정의
        - [ ]  방문자
            - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도 클래스로 구성하는 패턴
            - 분리된 처리 기능은 각 클래스를 방문하여 수행