# 4 응용SW기초기술활용

## 운영체제의 개념
* 운영체제(OS)
  * 컴퓨터 시스템 자원 효율적 관리
  * 유저와 하드웨어 간의 인터페이스로 동작하는 시스템 소프트 웨어
* 운영체제 목적
  * 처리 능력
  * 반환 시간
  * 사용 가능도 
  * 신뢰도
* 운영 체제의 기능
  * 자원 스케줄링
  * 사용자와 시스템 간 인터페이스
  * 시스템 오류 검사 및 복구
  * 자원 보호
  * 시스템 자원 관리
  * 입 출력 보조 
  * 가상 계산기
* 운영 체제의 주요 자원 관리
  * 프로세스 관리
    * 프로세스 스케줄링 및 동기화
    * 프로세스 생성 및 제거, 시작과 정지 등
  * 기억장치 관리
  * 주변 장치 관리
  * 파일 관리

## Windows의 주요 특징
* 그래픽 사용자 인터페이스(GUI)
* 선점형 멀티 태스킹
  * 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램 강제 종료 후 모든 시스템 자원을 반환
* Pnp(자동 감지 기능,Plug and Play)
* OLE(Object Linking and Embedding)
  * 응용 프로그램 간 개체 공유가 자유러움
  * 문자나 그림 삽입 편집 등
* 255자 긴 파일명
* 싱글 유저

## Unix / Linux / Mac OS
### Unix의 개요 및 특징
* 시분할 시스템을 우해 설계된 대화형 운영체제
* 대부분 C, 이식성 높고, 프로세스간 호환성 높음
* 다중 사용자, 다중 작업
* 통신망 관리용 운영체제로 적합
* 트리 구조의 파일 시스템
### Unix 시스템 구성
* 커널
  * 컴퓨터 부팅 후 주기억장치에 상주
  * 프로그램과 하드웨어 간의 인터페이스
* 쉘
  * 시스템과 사용자 간의 인터페이스
  * 명령어가 포함된 파일 형태로, 보조 기억장치에 존재
  * 파이프라인 기능 지원, 입출력 재 지정 가능
* Utility Program
  * 일반 사용자가 작성한 응용 프로그램 처리
  * Dos의 외부 명령어

## 기억 장치 관리 개요
보조 기억장치 - 주기억장치 - 캐시 기억장치 - 레지스터 순으로 관계를 맺음

* 보조 기억 장치에 있는 데이터는 주기억장치에 적재 후 CPU에 의해 액세스 가능
  * 보조 기억장치는 직접 CPU 접근 못함

### 기억 장치 관리 전략
* 반입
  * 보조 기억 장치에 보관 된 데이터를 __언제__ 적재할 거냐
  * 요구 반입
  * 예상 반입
* 배치 
  * 보조 기억 장치에 보관된 데이터를 __어디에__ 적재할 거냐
  * 최초 적합
  * 최적 적합
  * 최악 적합
* 교체
  * 주기억장치의 모든 영역이 사용되고 있을 때

## 주기억장치 할당 기법
주 기억장치에 어떻게 데이터를 할당할 것인가?

* 연속 할당 기법
  * 단일 분할 할당 기법
    * 오버레이
    * 스와핑
  * 다중 분할 할당 기법
    * 고정 분할 할당 기법
    * 동적 분할 할당 기법
* 분산 할당 기법
  * 페이징 기법
  * 세그먼테이션 기법

### 단일 분할 할당 기법
* 주기억장치를 운영체제와 사용자 영역으로 나누어 한 순간 한 명만 사용자 영역 사용
* 경계 레지스터 필요
* 프로그램 크기가 작으면 사용자 영역 낭비

* 오버레이 기법
  * 주기억장치보다 큰 사용자 프로그램 실행하기 위한 기법
  * 프로그램을 여러 조각 분할후 필요한 조각만 차례때로 적재
  * 주기억장치에 공간이 없으면 불필요한 조각 위치에 오버레이해서 적재
* 스와핑
  * 하나 프로그램 전체를 주기억장치에 넣다 뺐다함
  * Swap out, in
  * 페이징 기법으로 발전

### 다중 분할 할당 기법
* 고정 분할 할당 기법(정적 할당 기법)
  * 프로그램 할당 전 OS가 주기억장치의 사용자 영역을 여러개 고정 크기로 분할 준비상태 큐에 준비 중인 프로그램에 각 영역 할당
  * 프로그램 전체가 주기억장치에 위치해야 실행 가능
  * 내외부 단편화가 발생해 주기억 장치 낭비 많음
  * 실행할 프로그램 크기를 미리 알고 있어야함
* 가변 분할 할당 기법(동적 할당 기법)
    * 고정 분할 할당 기법의 단편화를 줄이기 위함
    * 프로그램을 주기억장치에 적재하기전 필요한 만큼만 영역 분할
    * 영역들 사이에 단편화 발생

## 가상기억장치 구현 기법/ 페이지 교체 알고리즘
* 보조기억장치 일부를 주기억장치처럼 사용하는 것
* 프로그램을 블록 단위로 나눈 후 가상 기억장치에 보관하다가, 필요시 요구되는 블록만 주기억장치에 불연속적으로 할당
* 주기억장치의 이용률과 다중 프로그래밍 효율 상승
* 주소 변환 작업 필요
* 연속 할당 방식으로 발생하는 단편화 해결 
### 페이징 기법
* 가상 기억장치의 프로그램과 주기억장치 영역을 동일하게 나눠 적재 후 실행하는 방법
* 내부 단편화 발생
* 페이지 맵 테이블 필요
* 페이지 맵 테이블 사용으로 비용 증가, 처리 속도 감소
### 세그먼테이션 기법
* 가상 기억장치에 보관된 프로그램을 다양한 크기로 쪼개고 주기억 장치에 적재
* 논리적 크기로 나눈 단위를 세그먼트
  * 세그먼트는 고유 이름을 가짐
* 세그먼트 맵 테이블 필요
* 기억장치 보호기 필요
* 외부 단편화 발생

#### 세그먼테이션 기법의 일반적인 주소 변환
* 가상 주소 = 세그먼트 번호 + 변위값
* 실기억주소 형식 = 실기억주소(세그먼트 기준번지 + 변위 값)
* 세그먼트 맵 테이블 = 세그먼트 번호 + 세그먼트 크기 + 기준 번지

* 주소 계산 방법
  * 가상 주소의 세그먼트 번호로 세그먼트 맵 테이블 조회
  * 세그먼트 크기와 변위 값 비교
  * 기준 번지 + 변위 값으로 주소 매핑

### 페이지 교체 알고리즘
* OPT(Optimal replacement, 최적 교체)
  * 가장 오랫동안 사용하지 않을 페이지 교체
  * 페이지 부재 횟수가 가장 적음
* FIFO(First In First Out)
  * 가장 오래 있었던 페이지를 교체하는 기법
  * 이해 쉽고, 프로그래밍 설계가 간단
* LRU(Least Recently Used)
  * 최근에 가장 오랫동안 사용하지 않은 페이지 교체
  * 페이지 마다 계수기나 스택으로 가장 오래 전 사용된 페이지 교체
* LFU(Least Frequently Used)
  * 사용 빈도가 가장 적은 페이지를 교체하는 기법
* NUR(Not Used Recently)
  * 최근에 사용하지 않은 페이지 교체
  * LRU의 시간적 오버헤드 줄이기 가능
  * 참조 비트와 변형 비트로 최근 사용 여부 확인
* SCR(SECOND chance Replcaement,2차 기회 교체)
  * 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지 교체 방지
  * fifo 기법의 단점 보완