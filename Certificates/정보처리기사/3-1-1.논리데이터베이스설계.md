# 3-1 논리데이터베이스설계

## 데이터베이스 설계

* 데이터 베이스 설계시 고려 사항
  * 무경설
  * 일관성
  * 회복
  * 보안
  * 효율성
  * 데이터 베이스 확장

* 데이터 베이스 설계 순서
  * 요구 조건 분석
  * 개념적 설계
    * 트랜잭션 모델링, E-R 모델링
  * 논리적 설계
    * 트랜잭션 인터페이스 설계
    * 관계형 데이터 베이스의 경우 테이블 설계
  * 물리적 설계
  * 구현
    * 트랜잭션 작성

## 데이터 모델의 개념

* 데이터 모델 구성 요소
  * 개체, 속성, 관계
* 데이터 모델 종류
  * 개념적, 논리적, 물리적
* 데이터 모델 요소
  * 구조, 연산, 제약 조건

### 데이터 모델

* 개념적 모델
  * E-R 모델 등
* 논리적 데이터 모델
  * 특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용
  * 관계 모델, 계층 모델, 네트워크 모델로 구분
  * 논리적 데이터 모델의 품질 검증
    * 개체
    * 속성
    * 관계
    * 식별자
    * 전반적인 품질 검증

## 데이터 모델의 구성 요소 - 개체(Entity)

### 개체의 정의 및 특징

* 현실 세계의 대상체
* 연관된 몇 개의 속성으로 구성
* 파일 시슽메 레코드에 대응
* 유일한 식별자에 의해 식별 가능
* 다른 개체와 하나 이상의 관계 가짐

### 개체명 지정 방법

* 해당 업무에서 사용하는 용어
* 약어 사용 제한
* 단수 명사 선호
* 유일
* 생성 의미에 따라 이름 부여

## 데이터 모델의 구성요소 - 속성

### 속성의 정의 및 특징

* 데이터 구성의 가장 작은 논리적 단위
* 파일 구조상의 데이터 항목 또는 데이터 필드
* 속성의 수는 디그리 또는 차수

### 속성의 종류

#### 속성의 특징에 따라

* 기본 속성
  * 업무 분석을 통해 정의
  * 가장 많고 일반적
* 설계 속성
  * 설계 과정에서 도출해낸 속성
* 파생 속성
  * 다른 속성으로부터 파생
  * 되도록 적게 정의 추천

#### 개체 구성 방식에 따라

* 기본키 속성
* 외래키 속성
* 일반 속성
  * 기본키, 외래키에 포함되지 않은 속성

### 속성 후보 선정 원칙

* 원시 속성으로 판단되는 속성 후보는 버리지 않음

### 속성명 지정 원칙

* 서술형으로 지정하지 않는다
* 약어 사용 제한
* 개체명은 속성명으로 사용 못함
* 유일

## 데이터 모델의 구성요소 - 관계

* 개체와 개체 사이의 논리적 연결
* 관계의 형태
  * 1 : 1
  * 1 : N
  * N : M
* 관계의 종류
  * 종속 관계
  * 중복 관계
  * 재귀 관계
  * 배타 관계
* 관계 표현
  * | : 필수
  * o : 선택적
  * < : 다중

## 식별자

* 하나의 개체 내에서 각각의 인스턴스를 유일하게 구분할 수 있는 구분자

### 식별자 분류

* 대표성 여부 : 주 식별자, 보조 식별자
* 스스로 생성 여부 : 내부 식별자, 외부 식별자
* 단일 속성 여부 : 단일 식별자, 복합 식별자
* 대체 여부 : 원조 식별자, 대리 식별자

### 주 식별자/ 보조 식별자

* 두 식별자 모두 개체를 유일하게 식별한다
* 보조 식별자는 한 개 이상 존재
* 주 식별자는 기본키, 보조 식별자는 유니크 인덱스로 사용

### 내부 식별자/ 외부 식별자

* 외부 식별자는 자신의 개체에서 다른 개체를 찾아가는 연결자 역할 수행

### 원조 식별자, 대리 식별자

* 대리 식별자(인조 식별자)는 주 식별자 속성들을 하나의 속성으로 묶어 만듬

### 후보 식별자

* 개체 내 각 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성 집합
* 하나 의 개체에는 한 개 이상 존재 해야함
* 후보 식별자 조건
  * 각 인스턴스를 유일하게 식별
  * 널 값이 될 수 없음
  * 속성 집합이 후보 식별자일 경우 개념적으로 유일해야함
  * 후보 식별자의 데이터가 자주 변경되면 안된다

## [A] E-R(개체- 관계) 모델

* 대표적인 개념적 데이터 모델로 피터 첸이 만듬
* 데이터를 개체 관계 속성으로 묘사
* 특정 DBMS를 고려한 것은 아님

## [C] 관계형 데이터 모델

* 2차원적인 표를 이용해 데이터 상호 관계를 정의하는 DB 궂
* 기본키와 이를 참조하는 외래키로 데이터 관계 표현
* 관계형 모델의 대표적 언어는 SQL

## [A] 관계형 데이터 베이스 구조

* 관계형 데이터 베이스를 구성하는 개체나 관계는 릴레이션(TABLE)로 표현
  * 간결하고 보기 편함, 변환에 용이
  * 성능이 다소 떨어짐

### 관계형 데이터 베이스

* 튜플
  * 속성의 모임
  * 레코드
  * 튜플의 수 :  카드널리티(기수,대응 수)
* 속성
  * 가장 작은 논리적 단위
  * 데이터 항목 또는 데이터 필드
  * 속성의 : 디그리(차수)
* 도메인
  * 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자 값

## [A] 관계헝 데이터 베이스의 제약 조건 - KEY

* 튜플들을 서로 구분할 수 있는 기준이 되는 속성

### 후보키

* 기본키로 사용할 수 있는 속성
  * 하나 이상 존재
* 유일성과 최소성을 만족해야함

### 기본키

* 기본키는 NULL 값을 가질 수 없다
* 유일성과 초소성을 가진다

### 대체키

* 기본키를 제외한 나머지 후보키

### 슈퍼키

* 속성들의 집합으로 구성된 키

### 외리키

* 다른 릴레이션의 기본키를 참조하는 속성

## [A] 관계형 데이터베이스의 제약 조건 - 무결성

* 무결성 : 부정확한 자료가 데이터 베이스 내에 저장되는 것을 방지하기 위한 제약 조건
  * 개체 무결성(실체 무결성)
    * 기본키를 구성하는 어떤 속성도 NULL이나 중복 될 수 없다.
  * 도메인 무결성(영역 무결성)
    * 주어진 속성 값이 정의된 도메인 값에 속해야한다
  * 참조 무결성
    * 외래키 값은 NULL이나 참조 릴레이션 기본키와 동일해야 한다
    * 외래키와 참조하려는 테이블의 기본키는 도메인과 속성 개수가 같아야한다
  * 사용자 정의 무결성

### 데이터 무결성 강화

* 애플리케이션
  * 무결성 조건을 검증하는 코드를 데이터 조작하는 프로그램에 추가
  * 복잡한 무결성 조건 구현 가능
  * 관리가 힘들고, 적정성 검토 어려움
* 데이터베이스 트리거
  * 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL
  * 통합 관리 가능, 복잡한 요구 조건 구현 가능
  * 운영 중 변경이 어려움, 사용상 주의 필요
* 제약 조건
  * 데이터 베이스에 제약 조건 설정
  * 통합 관리 가능, 간단하게 구현, 변경 용이, 오류 데이터 발생 방지
  * 복잡한 제약 조건 구현 및 예외처리 불가능

## [A] 관계대수 및 관계해석

* 관계 대수
  * 관계형 데이터베이스의 절차적 언어
  * 피연산자/연산자 모두 릴레이션
  * 순수 관계 연산자와 일반 집합 연산자 존재
* 관계 해석
  * 관계 데이터 연산을 표현하는 방법
  * 비절차적 특성
  * 튜플 관계해석과 도메인 관계해석 존재

## [A]정규화

* 종속성 이론을 이용해 잘못 설계된 관계형 스키마를 작은 속성으로 쪼개 바람직하게 만드는 과정

### 정규화의목적

* 데이터 구조의 안정성 및 무결성 유지
* 효과적인 검색 알고리즘
* 속성의 배열 상태 검증

### 이상(Anomaly)의 개념 및 종류

* 삽입 이상
* 갱신 이상
* 삭제 이상

### 정규화 원칙

* 정보의 무손실 표현
* 분리의 원칙
* 데이터 중복성 감소

### 정규화 가정

* 1NF
  * 모든 도메인이 원자값으로 구성되어야함
* 2NF
  * 부분적 함수 종속 제거
  * 모든 속성이 기본키에 대하여 완전 함수적 종속
* 3NF
  * 이행적 함수 종속 제거
  * 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속 만족 X
* BCNF
  * 결정자이면서 후보키가 아닌 것 제거
  * 결정자가 모두 후보키여야한다
* 4NF
  * 다치 종속 제거
* 5NF
  * 모든 조인 종속이 후보키를 통해서만 성립

## [B] 반정규화

* 의도적으로 정규화 원칙 위해
* 일관성 및 정합성 저하 가능
* 데이터의 일관성과 무결성 VS 데이터베이스 성능과 단순화

### 반정규화 구현

* 테이블 통합
  * 두 개 테이블에서 발생하는 프로세스가 동일하게 자주 처리 될 때 사용
  * 고려사항
    * 검색 간편 But 레코드 증가로 처리량 증가
    * 입력,수정,삭제 규칙이 복잡해 질 수 있음
    * 제약 조건 설계 어려움
* 테이블 분할
  * 수평 분할 : 레코드 기준 테이블 분할
    * 사용 빈도에 따라 테이블 분할
  * 수직 분할 : 속성 기준 테이블 분할
    * 갱신 위주의 속성 분할
    * 자주 조회되는 속성 분할
    * 크기가 큰 속성 분할
    * 보안 적용 속성 분할
    * 고려 사항
      * 기본키의 유일성 관리 어려움
      * 수행 속도 저하
* 중복 테이블 추가
  * 추가하는 경우
    * 수행 속도가 느림
    * 많은 범위 데이터 자주 처리
    * 특정 범위 데이터만 자주 처리
    * 처리 범위를 줄이지 않고는, 수행 속도 개선 불능
  * 방법
    * 집계 테이블
      * 집계 데이터를 위한 테이블 생성, 트리거 오버헤드 유의
    * 진행 테이블
    * 특정 부분 포함 테이블
* 중복 속성 추가
  * 자주 사용하는 속성 추가
  * 중복 속성 추가 경우
    * 조인이 자주 발생할 때
    * 접근 경로가 복잡할 때
    * 액세스 조건으로 자주 사용될 때
    * 기본키 형태가 적절하지 않거나, 여러 속성으로 구성된 경우
  * 고려 사항
    * 테이블 중복과 속성의 중복
    * 데이터 일관성 및 무결성
    * sql 그룹 함수 이용 처리 가능
    * 저장 공간이 지나친 낭비

## [B] 시스템 카탈로그

* 시스템과 관련된 다양한 객체 정볼르 가진 시스템 데이터 베이스
* 데이터 사전에 저장

### 저장 정보

메타데이터를 저장한다

* 데이터 베이스 객체 정보
* 사용자 정보
* 테이블 무결성 제약조건 정보
* 함수 프로시저, 트리거 등에 대한 정보

### 카탈로그 특징

* 일반 이용자도 SQL로 내용 검색 가능
* DBMS가 스스로 생성하고 유지
* INSERT, DELETE, UPDATE 문을 이용한 갱신 허용하지 않음
* 시스템 변화시 시스템이 자동 갱신
* 모든 제어 정보를 가지고 있음

### 카탈로그/데이터 사전 참조하기 위한 DBMS 내 모듈 시스템

* 데이터 정의어 번역기(DDL 컴파일러)
  * 카탈로그 생성 후 데이터 사전에 저장
* 데이터 조작어 번역기(DML 컴파일러)
  * 응용 프로그램에 삽입된 DML 문을 프로시저 호출로 변환하여 질의 처리기와 상호 통신
* Data Dictionary
  * 시스템만 접근 가능
  * 데이터 사전에 수록된 데이터 실제 접근에 필요한 정보 관리 유지하는 시스템
* 질의 최적화기
  * 사용자의 요구를 효율적 형태로 변환
  * 질의를 처리하는 좋은 전략 모색
* 트랜잭션 처리기
  * 복수 사용자 환경에서 동시에 일어나는 트랜잭션 문제를 해결
  * 데이터 베이스 자원을 배타적 사용하는데 도움
