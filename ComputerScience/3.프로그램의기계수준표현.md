# 3 프로그램의기계수준표현

일반적인 원리는 이해해도 자세한 내용은 바우고 싶지않다는 말은 자신을 속이는 것이다 기억하자

## 역사점 관점

* 프로세서의 역사에서 각각의 인접한 프로세서는 이전 버전과 호환성을 갖도록 설계가 되었다
	*이전의 모든 버전에서 컴파일한 코드가 모두 실행 가능하다
	
이러한 프로세서의 발전 때문에 많은 이상한 잔재들이 남아있다. 역사를 보아야 이해가 되는 것들이 생긴 것이다

## 프로그램의 인코딩

* gcc(c 언어 컴파일러)에서 -0g 옵션의 기능
	* 최적화된 코드 생성
	* 최적화 수준이 올라가고 프로그램 속도도 증가
	* 기계어 코드와 본래 소스 코드 간의 관계를 이해하기 어려움
	* 컴파일 시간 증가 및 디버깅 도구 실행의 어려움

### 기계 수준 코드

* 기게 수준 프로그래밍에서 중요한 추상화
	* ISA
		* 기계 수준 프로그래밍의 형식과 동작 정리
		* instruction aet architecture
		* 인스트럭션이 순차적으로 실행되는 것 같은 추상화 제공
	* 기계 수준 프로그래밍은 가상 주소를 사용
		* 메모리가 엄청 큰 바이트 배열처럼, 메모리 모델 제공

컴파일러는 전체 컴파일 순서에서 C에서 제공하는 추상화된 실행 모델로 표현된 프로그램을 기초적인 인스트럭션들오 변환하는 일을 한다

어셈블리어 코드가 기계어 코드와 다른 점은 바이너리 기계 코드와 비교했을 때 더 읽기 쉬운 텍스트 형식이란 것이다

* 프로세서가 사용하는 주요 요소들
	* PC
		* 실행할 다음 인스트럭션의 메모리 주소를 가리킨다
	* 정수 레지스터 파일
		* 64 bit 값을 저장하기 위한 16개의 이름을 붙인 위치를 갖는다
		* 주소, 정수 데이터, 프로그램의 상태 추적
	* 조건 코드 레지스터
		* 가장 최근이 실행한 산술, 논리 인스트럭션이 관한 상태 정보 저장
		* 조건문, 반복문을 구현할 때 필요한 제어나 조건에 따른 데이터 흐름 변경을 위해
	* 벡터 레지스터
		* 하나 이상의 정수나 부동소수점 값들 저장

* 기계어 코드의 입장
	* 메모리 = 바이트 주소 지정이 가능한 큰 배열
	* 데이터 타입을 구분 안함
	* 연결된 데이터 타입은 연속된 바이트로 바라본다

* 프로그램 메모리 가지는 것들
	* 실행 기계어 코드
	* 운영체제를 위한 정보
	* 프로사저 호출과 기턴 관리하는 런타임 스택
	* 사용자이 의해 할당된 메모리 블럭
	
	
하마의 기계어 인스트럭션은 매우 기초적인 동작만을 수행한다

### 코드 예제

* 컴퓨터에 의해 실행된 프로그램은 단순한 일련의 인스터럭션을 인코딩한 일련의 바이트라 여겨짐
* 컴퓨터는 소스 코드에 대한 정보가 거의 없다


* objdump -d [목적파일]
	* 유닉스에서 역 어셈블러 명령어

* 기계어 코드의 특징
	* 자주 사용되는 인스터럭션들과 오퍼렌드는 짧른 길이를, 그 반대의 경우 길다
	* 인스트럭션 형식은 주어진 시작 위치에서부터 바이트들을 유일하게 디코딩한다
	* 역 어셈블러는 기계어 코드 파일의 바이트 순서에만 전적으로 의존한다

### 형식에 대한 설명

```assembly
	.file
	.text
	.global	multstore
multstore:
	pushq	%rbx
	movq	%rdx %rbx
	...
	ret
```

* '.'으로 시작하는 모든 것은 어셈블러와 링커에 지시하기 위한 디렉티브들이다
	* 무시하도 된다
	* 어셈블리 코드를 깔끔하게 하기위해 생략해도된다
* 일반적으로는 위와 같이 어셈블리어를 적고 인스트럭션 옆에 주석으로 인스트럭션의 기능을 적는게 정형화된 방식이다

## 데이터의 형식

인텔 프로세서들은 근본적으로 16비트 구조에서 32비트로 확장했다

그렇기에 인텔에서 워드는 16비트 데이터 타입을 의미한다

gcc가 생성한 대부분의 어셈블리 코드 인스터력션들은 오퍼랜드의 크기를 나타내는 단일 문자 접미어를 가지고 있다

mov 뒤에 붙는 b w l q가 그것들이다.

1. movb(바이트 이동)
2. movw(워드 이동)
3. movl(더블워드 이동)
4. movq(쿼드워드 이동)

## 정보 접근하기

x86-64 주처리장치 CPU는 64비트 값을 저장하는 16개의 범용레지스터를 가지고 있다 이들 레지스터는 정수디이터와 포인터를 저장하는데 쓰인다

인스트럭션들은 16개의 레지스터 하위 바이트들에 저장된 다양한 크기의 데이터에 대해 연산할 수 있다

* 바이트 수준 연산은 바이트 연산에 접근
* 16비트 연산은 2바이트에 접근
* 32비트 연산은 4바이트에 접근
* 64비트 연산은 8바이트에 접근

일반적인 프로그램은 서로 다른 레지스터들을 서로 다른 목적으로 이용한다 하지만 스택포인터 %rsp로 런타임 스택 끝을 가리킨다. 일부 인스트럭션들은 특별히 이 레지스터를 쓴다 

나머지 15개는 비교적 사용이 좀 더 자유롭다

중요한 것은 레지스터는 표준 프로그래밍 관습에 따라 스택을 관리하고, 함수 인자를 넘기고, 함수 값을 리천, 로컬 임시 데이터를 저장한다

### 오퍼랜드 식별자

대부분의 인스트럭션은 하나 이상의 오퍼랜드를 가진다

* 오퍼랜드
	* 연산을 수행할 source
	* 결과를 저장할 목적지(destination)을 저장한다

source는 상수로 주어지거나 레지스터나 메모리로부터 읽는다

결과값은 레지스터나 메모리에 저장된다

* 오퍼랜드의 종류는 3 가지 타입으로 구분할 수 있다
	* immediate : 상수 값 의미
		* ATT 형식의 어셈블리 코드에서는 $로 표시
	* register : 레지스터의 내용
		* 16개의 64비트, 32비트,16비트,8비트 레지스터릐 하위 일부분인 8,4,2,1 바이트 중 하나의 레지스터를 가리킨다
	* 메모리 참조
		* 유효주소에 의해 메모리 위치에 접근한다

* 기본 레지스터와 인덱스 레지스터는 모두 64 비트이다.
	* 기본이 64비트 크기의 레지스터를 사용하기 때문
	* 인덱스 레지스터는 메모리 주소랑 관련있다

## 데이터 이동 인스트럭션

* 가장 많이 쓰이는 인스트럭션은 한 위치에서 다른 위치로 복사하는 명령이다

* 인스트럭션 클래스
	* 여러 개 인스트럭션을 모아  동일한 동작을 다른 오퍼랜드 크기를 사용하여 수행한다
	* 이 덕에 대이터 이동 인스트럭션이 간단해졌다

* 소스 오퍼랜드는 상수, 레지스터 저장 값, 메모리 저장 값을 표시한다
* 목적 오퍼랜드는 레지스터, 메모리 주소 위치를 지정

x86은 데이터 이동 인스트럭션에서 두 개의 오퍼랜드 모두가 메모리 위치에 올 수 없도록 제한하고 있다

하나의 메모리 위치에서 다른 위치로 어떤 값을 복사하기 위해서는 두 개의 인스트럭션이 필요하다

1. 소스 값을 레지스터에 적재하는 인스트럭션
2. 소스 레지스터의 값을 목적지에 쓸 인스트럭션

### 데이터 이동 명령어(클래스)

* MOV
	* 특정 오퍼랜드의 값을 지정된 메모리 위치에 업데이트

작은 소스의 값을 더 큰 목적지로 복사할 때는 아래의 명령어를 쓴다

* MOVS
	* 부호 있는 정수에 사용
	* 목적지에 남은 바이트들을 중요한 비트(1)로 채워준다
* MOVZ
	* 부호 없는 정수에 사용
	* 목적지에 남은 바이트들을 모두 0으로 채워준다


### 인스트럭션 사용법

```assembly
movl $0x4050, %eax
movw %bp, %sp
...
``` 

* 인스트럭션 - 소스 오퍼랜드 - 목적 오퍼랜드 순으로 나열된다
* 두 개의 오퍼랜드가 동시에 메모리 위치에 접근 못한다
* 상수, 레지스터, 메모리가 오퍼랜드 위치에 나타난다(메모리-메모리는 안된다)
* 레지스터의 크기는 인스트럭션의 마지막 문자가 나타내는 크기와 일치해야한다


### 데이터 이동 예제

* C언어에서 포인터라고 부르는 것이 어셈블리어에서는 단순히 주소이다
	* 포인터를 역참조하는 것은 포인터를 레지스터에 복사하고, 이 레지스터를 메모리에 참조에 사용하는 과정으로 이루어진다
* 지연 변수들은 메모리에 저장되기보다는 종종 렞스터에 저장된다
	* 레지스터의 접근은 메모리보다 속도가 훨씬 빠르다

### 스택데이터의 저장과 추출(Push, Pop)

* 스택은 프로시져 호출을 처리하는데 중요한 역할을 한다
* 스택은. 후입선출(last in first out)이다
* 스택의 탑(top) 원소는 모든 스택 원소 중 가장 낮은 주소를 갖는 형태이다
* 관련 인스트럭션으로는 pushq, popq가 있다
	* 한 개의 오퍼랜드를 사용한다
	* 추가할 소스 데이터, 추출을 위한 데이터 목적지

## 산술연산과 논리연산

* CPU는 인스트럭션 클래스에 따라 연산을 한다
	* 오퍼랜드의 길이에 따른 다양한 변형이 가능하다
* 연산들은 4개의 그룹으로 나누어짐자
	* 유효주소 적재
	* 단항
	* 이항
	* 쉬프트

### 유효주소 적재

* leaq는 유효 주소 적재 인스트럭션
	* 목적 오퍼랜드는 레지스터리다
	* 메모리를 참조하지 않는다
	* 첫 번째 오퍼랜드는 유효주소를 목적지에 복사
* 컴파일러는 실제 유효 주소계산과 무관할 때 leaq를 쓴다
	* 나름의 예외 처리인가

### 단항 및 이항 연산

* 단항 연산
	* Increment
	* Decrement
	* Negate
	* Complement

단한 연산은 하나의 오퍼랜드가 소스와 목적지로 동시에 사용되는 연산이다.

* 이항 연산
	* Add
	* Subtract
	* Multiply
	* Exclusive-OR
	* OR
	* AND

이항 연산에서는 두 번째 오퍼랜드는 소스이면서 목적지로 사용된다

### 쉬프트 연산

* SAL, SHL, SAR, SHR
* 쉬프트 명령어 - 쉬프트 크기(양) - 쉬프트 값(변수)
* 쉬프트 인스트럭션들은 쉬프트할 양을 즉시 값이나 단일 바이트 레지스터 %cl로 표시 할 수 있다
* 목적 오퍼랜드가 레지스터나 메모리 위치가 될 수 있다

우측 산술 쉬프트는 부호비트를 복사해서  우측부터 채운다. 나머지는 해당 방향부터 0을 채운다

### 특수 산술 연산

* oct word : 16 byte
* 아래의 인스트럭션들은 128bit 표현이다

* mulq(imulq) - source operand - %rax
	* mulq(imulq)는 위의 순서대로 인스터럭션을 실행한다
	* %rdx(상위 64bit) + %rax(하위 64bit )
* divq(idivq)
	* 피제수 : 128bit(%rdx + %rax)
	* 제수 : instruction operand
	* 몫은 %rax, %rdx는 나머지
* cqto
	* oct word로 변경
	* operand 없음
	* %rax 부호비트를 읽어 %rdx에 복사

## 제어문

* 기계어 코드의 인스트럭션들은 모두 순차적으로 실행된다
* 기계어 인스트럭션들의 실행 순서는 JUMP로 바꿀 수 있다

### 조건 코드

* CF
	* carry flag
	* 올림 발생한 것을 표시
	* 비부호형 연산에서 오버플로우 검출할 때 사용
* ZF
	* zero flag
	* 가장 최근 연산 결과가 0인 것을 표시
* SF
	* negetive
	* 가장 최근 연산이 음수를 생성한 것을 표시
* OF
	* overflow flag
	* 가장 최근 연산이 양수/음수의 2의 보수 오버플로우를 발생시킨 것을 표시

* 논리연산은 캐리와 오버플로우가 0으로 세팅된다
* 쉬프트 연산에서는 캐리 플라그가 쉬프트 되어 없어지는 마지막 비트로 설정된다
	* 오버플로우 플래그는 0이다
* INC,DEC 인스트럭션들은 오버플로우와 영 플래그를 세팅하지만, 캐리 플래그는 영향을 주지 않는다

#### t = a +b

* CF
	* (unsigned) t < a
* ZF
	* t == 0
* SF
	* t < 0
* OF
	* (a < 0 == b < 0) && (t < 0 != a <0)

#### CMP , TEST

* 다른 레지스터들은 변경시키지 않으면서 조건 코드만 변경해 주는 인스트럭션이다

* CMP 인스트럭션
	* 두 오퍼랜드의 차에 따라 조건 코드를 설정한다
	* 목적지를 갱신하지 않고 조건 코드를 설정
		* 위의 조건을 제외하면 SUB 인스트럭션과 같이 동작한다
* TEST 인스트럭션
	* 목적지를 갱신하지 않고 조건 코드를 설정
		* 위의 조건을 제외하면 AND 인스트럭션과 같이 동작한다

###  조건코드 사용하기

* 조건 코드를 직접 읽음
* 조건 코드의 조합에 따라 0 또는 1 을 한 개 바이트에 기록
* 조건에 따라 프로그램의 다른 부분으로 이동하는 법
* 조건에 따라 데이터 전송

* SET 인스트럭션
	* 다른 접미어를 가짐
		* 접미어가 오퍼랜드 크기를 나타내지 않음
		* 어떤 조합을 사용할지
	* 다른 조건 코드 조합으로 서로 다른 동작을 함
	* 목적지로 하위 단일 바이트 레지스터나 메모리 주소 사용

### JUMP instruction

* 프로그램이 완전히 새로운 위치로 실행을 전환
* JUMP 목적지는 어셈블리 코드에서는 lable

* 어셈블러는 목적코드를 만들기 위해
	* 모든 레이블이 붙은 인스트럭션 주소 결정
	* JUMP target encoding

* 직접 접근
	* 인스트럭션의 일부로 인코딩 되는 경우
	* 점프 대상을 레이블로 작성
* 간접 접근
	* 레지스터, 메모리 위치부터 읽어들여야하는 경우
	* * 또는 메모리 오퍼랜드 사용

* 조건부 JUMP : 직접 점프만 가능

### 조건부 분기를 조건제어로 구현하기

* C에서 조건부 수식과 문장 기계어 코드번역하는 법
	* 조건부 및 무조건 JUMP 사용
	* 데이터 이동

```shell
if(test-expr)
	then-statement
else
	else-statement
```

* 컴파일러는 else 문과 then 문에 대해 별도 코드 블럭 생성

### 조건부 이동으로 조건부 분기 구현

* 조건부 동작은 제어의 조건부 전환을 통해 구현
* But 데이터 조건부 전송은 조건부 동작의 산출물 모두 계산 후 선택
* 데이터 전송은 특정 환경에서 효율적임
	* 현재 최신프로세서에서 JUMP 인스트럭션 실행시간을 빠르게 예측하기에 채택함

* Tavg(P) = (1-p)Tok + p(Tok + Tmp)
	* P : 예측 오류 확률
	* Tok : 예측 오류 없는 코드 실행 시간
	* Tmp : 예측 오류로 인한 손실

* 조건부 이동 명령은 고정 8클럭 사이클 손실
* 데이터 이동은 평균 분기 예측 오류 손실과 변동 사이클을 가짐
	* 예측 오류 손실 범의를 산정할 수 있다.

### 어떻게 조건부 데이터 이동을 통해 구현되는가

```c++
v= test-expr ? then-expr : else-expr
if(!test-expr)
	goto false;
v= then-expr
	goto done;
false:
	v= else-expr;
done;
```

* 조건부 데이터 이동이란 조건부 동작의 산출물을 모두 계산하고 조건에 따라 하나만 선택하는 방식이다
	* 최신 프로세서들의 연산에서 잘 동작한다
	* 특정 환경에서 효율이 높음, 항상 코드의 효율성을 높인다 할 수 없다
		* 모두 계산하고 그 중 최적의 것을 사용하는 방식인데 코드 계산을 많이 요할 경우 효율이 떨어짐다
		* 컴파일러는 낭비되는 계산향과 예측 오류에 의한 잠재적 성능 손실 사이의 상대적 성능 고려가 필요함

* 모든 조건부 수식들이 조건부 이동으로 컴파일 되지 않음
	* 테스트 결과에 상관없이 then-expr과 else-expr 실행

### 반복문

* 조건부 Test + Jump를 이용해 반복문 구현

#### Do-While 반복문

* 아래는 do-while의 기본 형태이다

```c
do
	body-statement
	while(test-expr)
```

이를 goto 문으로 나타내면 

```c
loop:
	body-statement
	t = test-expr;
	if(t)
		goto loop;
```

* 반복문의 리버싱이서 프로그래과 레지스터 간의 매핑을 찾는게 중요하다
	* 복잡할수도 있음

#### While loop

```c
while(test-expr)
	body-statement
```

* test- expr을 먼주 실행한다
* while-loop는 번역법에 따라 2가지로 갈린다
	* loop 마지막에 Test로 무조건 점프 수행위한 초기 테스트 진행
	* 조건형 - do
		* test 실행시 loop 건너 뛰도록 조건부 분기로 do-while 번역
		* 조건부 분기를 이용해 do-while loop로 번역하는 방법

* 아래는 조건형 - do 표현법이다

```c
t= test-expr
if(!t)
	goto done
done:
	ret

```

```c
t = test-expr
if(!t)
	goto done;
loop:
	body-statement
	t = test- expr
	if(t)
		goto loop;
done:
	ret
```

#### For 반복문

```c
for(init-expr;test-expr,update-expr)
	body-statement
```

위의 기본적인 for문을 컴파일러는 while 문으로 변환해 인식한다

While과 do- while 중 코드 최적화 수준을 보고 결정한다

```c
init-expr
while(test-expr){
	body-statement
	update-expr
}
```

### Switch 문

* 정수 인덱스 값에 따라 다중 분기 기능 제공
* Jump table 자료구조 사용
	* 점프 테이블이란 프로그램이 실행해야할 동작을 구현하는 코드 블럭의 주소가 인덱스가 되는 배열
	* 이 코드는 점프 목적지를 찾기 위해 점프 테이블을 배열처럼 참조

* Jump table을 이용해 코드 위치 참조
* Jump Instruction은 *로 시작함
	* 오퍼랜드는 index 값을 저장하는 레지스터 %eax가 메모리 위치를 지정하는 색인으로 이용된다

* 코드 블럭이 동일할 경우 같은 코드 레이블을 이용해 이중 case를 사용
* case가 없을시 default Case로 이동한다


* 어셈블리 코드에서 점프 테이블은 아래처럼 지정된다
	* 점프테이블은 .rodata(Read-only 데이터)에 저장
		* .rodata는 목적코드 세그먼트 내에 존재

## 프로시저

* 프로시저 호출은 소프트웨어에서 추상화의 주요 기법이다
	* 이는 지정된 인자들과 리턴 값으로 특정 기능을 구현하는 코드를 감싸는 방법 제공
		* 함수를 말하는 것 같다
		* 여러 곳에서 호출 가능하다

* 프로시저는 간결한 인터페이스 정의와 일부 동작의 구체적인 구현은 감춰주는 방식으로 추상화 매커니즘을 이용한다

#### 프로시정 매커니즘

* 제어권 전달
	* PC는 리턴 시 다음 프로시저를 호출하는 인스트럭션을 설정해야한다
* 데이터 전달
	* 프로시저간 하나 이상의 매개변수를 전달할 수 있다
* 메모리 할당과 반납
	* 프로시저는 시작할 때 지역변수들을 위한 공간을 할당할 수 있고, 리턴시 이를 반납한다.

### 런타임 스택

* 프로그램은 스택을 이용해 프로시저가 요구하는 저장소를 관리한다
	* 스택은 제어와 데이터 전송 위해, 메모리 할당에 필요한 정보 저장


* Stack Frame이란?
	* 프로시저가 레지스터에 저장할 수 있는 개수 이상 저장 공간을 필요로 할 때 스택에 할당되는 영역
		* 현재 실행 중인 프로시저에 대한 프레임은 Stack의 제일 위이다

* 프로시저 P가 프로시저 Q를 호출한다고 가정하자
	* 호출 시 P는 리턴 주시를 스택에 푸시한다
		* Q가 리턴시 P에서 프로그램 재시작 위치를 설정하기 위해서다
	* 리턴 주소로 P에 관계된 상태를 저장하기 때문에 리턴 주소는 P 스택 프레임에 속한다 생각한다
	* Q에 대한 코드는 현재 Stack 경계를 확장해 자신의 스택 프레임 공간 할당
		* 스택 프레임에는 레지스터 값, 지역변수 공간 할당, 자신을 호출하는 프로시저들을 위한 인자 설정
* 대부분의 프로시저의 스택 프레임들은 프로그램 시작시 고정크기를 가짐
* 프로시저는 시공간 효율성을 위해, 요청받은 스택 프레임 부분만 할당(아래 예시 좀재)
	*  많은 프로시저가 6개의 인자를 가지나 레지스터를 통해 매개변수를 전달한다
	* 스택프레임을 요청하지 않는 함수도 많다
		* 위에서 말한 함수는 모든 지역변수를 레지스터에 저장하기도함

### 제어의 이동

* P->Q호 ㅈ어 전달하는건 PC에 Q 코드의 시작주소를 설정하면된다
	* 반대로 Q가 리턴할 땐 P에서 재 실행할 코드의 위치 일부를 가지고 있어야한다
	* Call Q 인스트럭션은 스택에 리턴 주소를 푸시 후 PC를 Q의 시작위치로 바꾼다


* Call procedure
	* Call Label, * Operand
	* 프로시저 Q 호출 
	* 리턴주소를 스택에 푸시, PC를 다음 함수 시작으로 설정
		* 리턴 주소는 call 다름 인스트럭션 주소
	* Call은 소출된 프로시저가 시닥하는 인스트럭션 주소를 목적지로 갖는다
	* Call 주소 호출할 함수
* Ret는 리턴주소를 스택에서 팝 해오고, PC를 리턴 주소로 설정
	* Return from call

* %rsp는 스택포인터, %rip는 프로그램 카룬터
* 인스트럭션 실행후 레지스터 등록

### 스택에서의 지역 저장 공간

* 지역 데이터를 메모리에 저장하는 경우
	* 지역 데이터르루모두 저장하기엔 레지스터 수 부족
	* 지역 변수 연산자 &가 사용, 변수에 대한 주소 생성 필요
	* 일부 지역 변수들이 배열 또는 구조체여서, 참조로 접근할 때
* 프로시저는 스택 포긴터를 감소시켜 공간할당
	* 이렇게 생긴 공간은 Local Variables라고함
* STACK 운영방식
	* %rsp를 감소시켜 공간을 할당한다
	* 그 후  데이터 값을 저장한다
	* 스택 포인터를 조정하여 지역 변수를 스택에 저장한다
	* 저장된 지역 변수를 사용하고 싶을 땐 Register에 복사 후 사용, 계산 끝나면 Stack Frame 증가시킨다

### 데이터 전송

* Procedure Call은 데이터 전달, 데이터 인자 전달을 한다
	* 데이터 전달은 레지스터를 통해 일어난다
* X86-64는 6개의 정수와 포인터를 저장할 수 있다
	* 데이터 길이에 따라 순서가 필요하다
	* 인자가 6개 이상시 Stack 사용한다
	* 충분한 크기의 저장 공간을 Stack Frame이 할당한다
		* 6개 초과한 인자들은 Stack top에 넣는다
	
* 스택에 전달할 모든 매개 변수는 8의 배수로 반올림한다

### 레지스터를 이용하는 저장소

* 프로그램 레지스터는 모든 프로시저들이 공유하는 단일 자원 역할
* 오직 하나의 프로시저만이 활성화 가능
	* 호출자 프로시저가 피호출자 프로시져를 호출 할 때, 피호출자 프로시져는 호출자 프로시져가 사용할 레지스터를 사용하지 않는다
* 관습적으로 레지스터 %rbx,%rbp,%r12-15는 피호출자 저장레지스터로 쓰인다
	* 프로시져 간 호출-리턴 시 호출자 프로시져긔 레지스터를 보존한다
* 레지스터 값 보존
	* 피호출자 프로시저는 호출자의 값을 변경안하거나 스택에서 이전 값을 스택에 푸시해둠
		* 푸시한 값은 Saved registers란 영역에 저장된다 (스택프레임에 생성)
* 스택 포인터를 제외한 모든 레지스터들은 호출자-저장 레지스터를 구분한다
* 지역 데이터를 레지스터에 보관

### 재귀 프로시저

* 프로시저 콜은 스택 상에 자신만의 사적 공간이 존재한다
	* 다수의 별도의 호출들의 지역 변수들은 서로 간섭하지 않는다
* 스택은 프로시저가 호출시 지역저장소 할당,리턴 전 반환한다
* 함수의 재귀적 호출도 다른 함수와 동일하다
	* 스택 기법 사용
		* 함수 호출시 상태정보를 위한 개별저장공간을 제공
		* 필요시 지역 변수저장공간 제공가능

## 배열의 할당과 접근

* C에서는 배열을 스칼라 데이터보다 큰 자료형으로 연계
	* 포인터 간의 연산은 기계어에서 주소 계산방식으로 연산된다

### 기본 원리

* T : 자료형, N : 정수형 상수 , L : 바이트 단위

* T A[N];
	* L*N 바이트의 연속적인 공간을 메모리에 할당
	* 새로운 식별자 A를 통해 배열 시작하는 위치의 포인터 사용
	* 배열의 원소는 주소 Xa + L*i에 저장

* 포인터 자료형은 8바이트이다

### 포인터 연산

* 단항 연산자 &, * 은 포인터의 생성과 역참조 수행
* 식 EXPR에 대해 &EXPR은 그 객체의 주소를 주는 포인터
*  주소를 나타내는 식에 대해 단항 연산자는 역참조를  말한다

* A[i] = *(A+i)

### 다중 배열

* 다차원 배열은 일반적인 배열 생성 규칙을 따른다

* C는 2차원 배열의 크기
* L은 자료형 크기

```assemble

 T D[R][C];
 & D[i][j] = Xp + L{C * i + j}
 
```

### 고정 크기 배열

* 최적화
	* 정수 인데스 제거
	* 배열 참조를 포인터 역참조로 바꿈

### 가변크기 배열

* C에서는 malloc이나 calloc 함수를 사용해 배열에 저장 공간을 할당한다
	* 행-우선 인덱싱을 사용해야함
* 고정 크기 배열을 일반화해 가변 크기 배열을 나타 낼 수 있다
* 프로그램이 다중 배열 원소 접근시 발생하는 패턴을 찾아라!
	* 곱셈은 피하도록 코드를 생성하자
		* 곱셈은 일부 프로세서에서 성능 저하를 유발한다

## 이기종 자료구조

C언어세오는 서로 다른 유형의 객체를 연결해서 자료형을 만드는 두 가지 방법을 제공한다

* 구조체(struct)
* 공용체(union)

### Struct

* 서로 다른 유형의 객체들을 하나의 객체로 묶어주는 자료형
	* 하나의 구조체 내의 서로 다른 컴포넌트들은 이름을 이용해 참조한다
	* 메모리의 연속된 영역에 저장한다

### 공용체(Union)

* 하나의 객체가 다수의 자료형에 참조 될 수 있도록
	* 동일한 블록을 참조
* 유니온의 크기는 구성하는 필드 중 크기가 가장 큰 것과 동일
* 장점
	* 서로 다른 두 개의 필드를 상호배타적으로 사용시, 전체 할당공간을 줄일 수 있음
	* 서로 다른 자료형들의 비트 패턴 정리시 사용

### 데이터의 정렬

* 정렬 제한
	* 프로세서와 메모리 시스템 간의 인터페이스를 구성하는 하드웨어 설계를 단순화
* 인텔의 경우 시스템 성능 개선을 위해
	* K의 배수 주소 정렬 방식을 사용한다
		* K의 배수는 아래와 같은형 식을 가진다
		* 객체가 K의 배수 주소에서 시작
		* 최소한의 오프셋을 추구한다
			* 패딩을 최소화
|K|Type|
|------|---|
|1| Char |
|2| short |
|4| int float |
|8| long double |

* 정렬은 모든 각체들 각각의 정렬제한 사항을 만족하는 방식으로 할당 강요

## 기계 수준 프로그램에서 제어와 데이터의 결합

###포인터 이해하기

* 포인터는 다른 자료구조 내 원소들이 대한 참조를 생겅하는 통일된 방법의 역할을 수행
	* 포인터는 객체를 가르킨다
		* malloc 함수같이 특수한 void* 형 범용 포인터는 형변환을 통해 자료형을 갖게한다
	* 모든 포인터는 특정 자료형을 갖는 객체의 __주소__ 를 가진다
	* 포인터는 & 연산자를 사용해서 만든다
		* 연산자 &의 기계어 코드 구현은 leap 인스트럭션을 사용해 계산한다
		* leap인스트럭션은 메모리 참조 주소를 계산하기 위해 만들어졌다
	* 포인터는 *를 사용해서 역참조한다
	* 배열과 포인터는 밀접한 관련이 있다
	* 한 종류의 포인터에서 다른 종류로의 자료형 변환은 종류만 바뀔 뿐 값은 변화가 없다
	* 포인터는 함수를 가르킬 수도 있다.

### 디버거 사용하기

* 디버거를 사용하는 일반적인 방법
	* 브레이크 포인트를 프로그램에서 관심있는 부분 근처에 설정
		* 함수 시작 전후
		* 프로그램의 특정 주소	
	* 실행 중단 후 제어를 사용자에게 넘김

### 범위를 벗어난 메모리 참조와 오버플로우

아래 2가지는 오류를 발생시킨다

* C에서 배열 참조시 범위 체크 안함
* 상태 정보(레지스터에 저장된 정보, 리턴 주소)를 스택에 저장

* 버퍼 오버플로우
	* 스택 프레임에서  리턴 주소가 스택에 먼저 저장되고 함수 관련 정보들이 스택 프레임에 할당 될 때 할당된 스택 프레임을 초과하는 값이 입력 될 때 발 상

* 버퍼 오버플로우를 이용한 공격을 실행 코드를 임코딩하고 그 코드의 포인터를 리턴주소에 덮어 싀운더

### 버퍼오버플로우 공격 대응

* 스택 랜덤화
	* 동일한 프로그램과 운영체제를 사용하는 모든 시스템에서 스택의 위치는 컴퓨터간 안전적이다
	* 스택랜덤화는 프로그램의 매 실행마자 스택의 위치를 다르기 한다
	* 프로그램 시작시 0~n 바이트 사이의 랜덤크기를 할당한다
	* 리눅스 표준인 ASLR(주소공간 배치 랜덤화)과 관련있다. 
		* 여러 프로그래 부분들이 매 실행 때 마가 다른 지역에 로딩
		* 브루트 포스 공격을 사용해 뚫릴 수 있음
			* nop 인스트럭션을 실행코드에 삽입한다
				* 이는 프로그램에서 슬라이드한다 표현
* 스택 손상 검출
	* 대개 프로그램이 지역 버퍼의 경계를 벗어날 때 발생
	* 특별한 캐너리를 생성한다 --> guard value라 부름
		* 랜덤 생성(공격자가 예측하기 어려움)
		* 카나리 값이 변경되어 있는지 체크
			* 에러시 종료
		* Read -Only
		* 매우 작은 성능 저하
* 실행 코드 영역 제한
	* 어느 메모리 영역이 실행코드를 저장할지 지한
	* 스택은 읽기와 쓰기 기능 유지
	* 컴파일러가 만든 코드를 저장하는 메모리 부분만 실행가능하도록

### 가변 크기 프레임 지원

* 일부 함수들은 가변적인 지역 저장동간 크기를 필요로 한다
	* 이를 위해 스택에 임의의 크기 바이트를 할당하는 표준 함수 alloca를 사용한다
* X86-64 코드는 레지스터 rbp를 프레임 포인터로 사용해 가변 크기를 저장한다
	* 레지스터 rbp는 피 호출자 저장 함수이므로 프레임 포인터로 사용할 시 기존의 값을 저장하고 사용한다

## 부동 소수점 코드
### 부동 소수점 코드 이동 및 변환

* 부동 소수점 아키텍쳐
	* 부동 소수점 값들이 저장되고 접근되는 방법
	* 부동 소수점 데이터로 연산하는 인스트럭션들
	* 함수들의 인자와 리턴 값으로 부동 소수점 값을 전달하기 위해 이용되는 관례들
	* 함수 호출하는 동안 레지스터에 보존하는 관례들
* 부돈 소수점 이동 및 연산
	* 스칼라 인스트럭션
		* 메모리 참조 인스트럭션
		* 개별 값들이 대해 연산한단걸 의미
	* 메모리 참조는 정수 mov 인스트럭션들과 동일한 방식으로 표기
* 메모리 이동
	* 단일 정밀도 vmovaps
	* 이중 정밀도 vmovapd
* 부동 소수점을 정수로 변환할 때 정상 수행

* vcvtsu2sdq
```assembly
vcvtsu2sdq %rax %xmm1 % xmm1
```

* 레지스터 xmm1은 상위 값에만 영향을 준다

* 단일 정밀도를 이중 정밀도로 바꾸는 법

```assembly
vunpcklps %xmm0 %xmm0 %xmm0
vcvtps2pd 
```
 
* vunpcklps의 앞의 두 인자는 서로 엮어서 마지막 인자에 저장된다
* vctps2pd는 레지스터 xmm의 두개의 하위 단일 정밀도를 이중 정밀도로 확장한다

* 이중 정밀도를 단일 정밀도로 바꾸는법

```assembly
vmovddup %xmm0 %xmm0
```

### 프로시저에서 부동 소수점 코드

* 포인터와 정수는 범용 레지스터 이용
* 부동 소수점 값은 xmm 레지스터 이용

### 부동 소수점 산술 연산

* 인자간 산술 계산시 형변환 필수
* 각 연산은 단일 정밀도와 이중 정밀도니 대한 인스트럭션을 가짐
