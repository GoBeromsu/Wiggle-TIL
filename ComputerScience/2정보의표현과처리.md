# 2정보의표현과처리

# 2 정보의표현과처리
## 정보의 저장

대부분의 컴퓨터들은 메모리에서 주소지정이 가능한 최소단위 비트인 __바이트__ 를 사용한다

기계 수준 즉 하드웨어 수준에서 프로그램은 메모리를 가상 메모리라는 거대한 바이트 배열 취급한다

* 가상 주소 공간
	* 모든 가능한 주소들의 집합
	* 주소 : 각 바이트를 식별케한다

모든 프로세스는 가상 주소공간을 부여 받는다(메모리 공간이란 뜻은 아니다)

기계 수준의 프로그램은 각 프로그램의 객체를 바이트 블록, 프로그램 자신은 바이트의 연속으로 취급한다

### 16진수

이진수 표시는 너무 장황하고, 십진수 표시는 비트 패턴으로 변환해야하니 불편하다. 그래서 16진수가 채택되었다.

기계 수준 프로그램은 일반적으로 비트 패턴을 십진, 이진, 16 진수 간에 수동으로 변환한다.

### 데이터의 크기

* 모든 컴퓨터는 워드 크기를 규격으로 가진다.
	* 이는 포인터의 정규 크기를 표시한다

* 가상 주소공간의 최대 크기는 워드 크기에 의해 결정된다.
	* 하나의 가상 주소가 한 개의 워드로 인코딩된다.
	* x bit인 워드의 경우 가상 주소 공간은 2^x 바이트이다

이해를 돕자면 32bit 워드는 가상 주소 공간의 크기가 약 4 GB이다. 그래서 32bit 컴퓨터는 메모리를 최대 4GB까지 밖에 인식 못한다.

* 32비트 머신과 64비트 머신을 위한 프로그램을 만들 때 어떻게 컴파일되었는가가 핵심이다
	* 64비트 머신은 역변환 호환성을 가진다.


#### 프로그래머들은 그래서,,

* 고정된 정수형 크기를 이용하는 것이 프로그래머들이 데이터 표현을 안전하게 통제하는 방법이다
* 여러 종류의 컴퓨터와 컴파일러에서 동작할 수 있도록 노력해야한다

### 주소 지정과 바이트 순서

여러 바이트에 걸쳐 있는 프로그램 객체들을 다룰 때 우린 2가지 규칙을 써야한다

1. 객체의 주소가 무엇이 되어야하는지
2. 메모리에 바이트들은 어떻게 정렬해야 하는지

객체의 주소는 사용된 바이트의 최소 주소로 정한다

예를 들어 int 타입 변수 X가 주소 0x100을 가진다면 32bit 즉 4 바이트 크기의 X는 0x100,101.102,103에 저장될 것이다

바이트 정렬엔 두 가지 규칙이 있다

* 리틀 엔디안
	* 가장 덜 중요한 비트가 먼저 온다
	* 비트 표시시 가장 뒤에 있는 비트부터 저장
* 빅 엔디안
	* 가장 중요한 비트가 먼저 온다
	* 비트 표시시 가장 앞에 있는 비트부터 저장

바이트 정렬로 인한 문제가 있다. 컴파일된 프로그램은 동일한 결과를 출력하지만

1. 이진 데이터가 네트워크를 통해 다른 컴퓨터로 전송 될 때이다
2. 정수 데이터를 나타내는 바이트들을 살펴 볼 때이다
3. 정상적인 타입 체계를 회피하도록 작성 되었을 때
	* 굳이? 싶지만 시스템 수준 프로그램에서는 유용하고 필요하다
	
#### 알고가자 C언어

```c
typedef int *int_pointer;
int_pointer ip;
```

int_pointer의 타입은 int 포인터이다.
ip는 주소를 담을 것이다

### 스트링의 표시

각 문자들은 표준 인코딩에 따라 표시된다. 일반적으로 인코딩은 ASKII 문자코드이다. 

즉 문자의 주소는 16진수로 표시될 때 아스키코드 값을 따라간다

### 코드의 표현

같은 코드를 컴파일 후 기계어 코드를 보면 컴퓨터 타입에 따라 인스트럭션들의 인코딩이 다른 것을 알 수 있다.

결론 프로그램은 컴퓨터 관점에서 단순한 바이트의 연속일 뿐이다. 본래 소스 프로그램에 대한 정보를 전혀 가지고 있지 않다

### Boolean 대수

불린 대수란 이진수 값 0, 1을 논리값 True False초 인코딩하여 대수학을 수식화 할 수 있다.

### 논리연산

* ^ : OR
* & : AND
* | : EXCLUSIVE-OR
* ~ : NOT

## 정수의 표시

정수를 표시하는 방법에는 여러가지가 있다

* 양수만 표시하는 법
* 음수, 양수, 0 모드를 표시하는 방법

## 쉬프트 연산

* 산술 연산
	* 1을 추가한다
	* 이는 부호형 정수 데이터 연산에서 유용하다
		* 부호형 정수는 1을 앞 비트에 추가하며 수를 확장시키기  때문이다
* 논리 연산
	* 0을 추가한다

### 비 부호형 인코딩

* B2U(unsigned to binary)
	* 2^n 개의 데이터 저장(n은 비트 수)
	* 2^n - 1은 최대 크기
	* 전단사 특징을 갖고 있다
		* 값이 유일하다
				
### 2의 보수 인코딩

* B2Tw(2의 보수 인코딩)
	* 표현 범위 : -2^n ~ 2^n 
	* 첫 번째 비트로 음수 양수 판단
	* 전단사 특징을 가진다

* 가능한 표현의 수가 음수가 양수보다 1개 많다
	* 0 때문이다

### 비 부호형과 부호형간의 변환

핵심은 숫자 값은 변해도 비트 패턴은 변하지 않는다는 것이다

* 2의 보수 표현과 비부호형 간에 양방향으로 변환 효과를 얻을 수 있다
	* 양수 영역은 모두 동일한 영역을 차지한다.
	* U2T = u - 2^n
* 비부호형의 음수 영역이 부호형으로 변환 될 때 음수 영역이 부호형의 양수 영역에 포함된다.

### 수의 비트 표시 확장하기

* U2U(unsigned to unsigned)
	* 비부호형의 경우 단순히 앞에 0을 추가한다
		* 이를 0의 확장이라고 한다
* T2T(two's complement to two's complement)
	* 부호형의 경우 앞에 1을 추가한다

이렇게 확장을 하다보면 부호형과 비부호형 간의 변환 과정과  수의 확장 순서에 따라 값이 달라질 수 있으니 조심하도록

## 정수의 산술 연산

컴퓨터는 계산을 할 때 2의 보수를 사용한다. 그래서 우린 그 과정을 알아야한다. 

정수를 2의 보수로 변환하는 과정을 이용해 오버플로우들을 감지한다.

### 비부호형 덧셈

* (x,y) 0 <= x,y < 2^w
	* w는 비트
	* x와 y는 비음수이다
* 덧셈에 필요한 비트 수 = w + 1
* 완벽한 산술 연산을 위해서는 워드 크기를 제한 하면 안된다

* + uw 연산(수식 표현이 안되서 일단 이렇게 한다)
	* X+Y 정수 합을 w비트 길이 내에서 계산 후 넘는 부분을 절삭 후 다시 비부호형 정수로 나타내는 연산

* mod : modular 계산
	* 21mod16은 5 이다
	* mod는 흔히 나머지 계산 법이라 생각한다

* 비부호형 덧셈에서 오버플러우 감지하기
	* s = x + (y - 2^w) < x
	* x + y > 2^w이면 오버플로우이기 때문이다
	* XmodY에서 X가 결과 값보다 크면 오버 플로우다
	* s = x + y - 2^w 이다
* 비부호형 비트 반전
	* x (x = 0)
	* 2^w - x (x > 0)

결국 위의 원리가 가능한게 제한된 비트 수의 덧셈에서 비트 길이 +1만큼의 비트가 있어야 완전한 덧셈 결과를 낼 수 있단걸 이용했다

### 2의 보수 덧셈

2의 보수 덧셈 또한 완전히 데이터 값을 표현하려면 w + 1 비트가 필요 할 수 있다 

* x + tw y
	* x + y를 w비트 길이로 절삭한 후에 2의 보수로 결과를 나타내는 연산으로 정의
	* (positive overflow) x + y - 2^w
	* (normal) x + y
	* (negetive overflow) x + y + 2^w

양의 오버플로우인데 2^w를 빼는 이유는 x + y의 값이 제한된 비트에서의 2의 보수 표현 범위를  벗어났기 때문이다

* 오버플로우 감지
	* 오퍼랜드가 (2^w-1) <= x + y < (2^w-1)를 벗어나면 오버플로우이다
	* x>0, y>0 일 때 s <= 0 양의 오버플로우
	* x<0, y<0 일 때 s >= 0 음의 오버플로우

### 2의 보수에서의 비트 반전

비트 반전이 중요한 이유는 제한된 비트 내에서 수의 표현 범위를 넓힐 수 있기 때문이다

2의 보수에서 비트 반전을 통해 음수를 표현한다

정수 x를 비트 반전을 시켜보면

* -x = ~ x + 1 (~x는 x의 비트 반전 상태이다)

### 비부호형 곱셈

* C에서의 비부호형 곱셈은 2w 비트 정수 곱의 하위 w비트 만드는 것이다

역시나 비트가 제한되어있다 이를 이용한다.

비부호형과 부호형 비트 곱셈은 두 비트를 곱하고 주어진 비트대로 절삭하면 비부호형과 부보형 모두 같은 표현을 보인다

## 부동 소수점

* V = x *2^y 형태 소수 인코딩

### 비율 이진수

* 비율 2진수는 x*2^y 로 나타낼 수 있는 수만 표시
* 다른 값은 근사화 시킴
	* 이진 표시을 길게 늘려 정확도 향상

### IEEE 부동 소수점 표시

* 위치 기반 표기법은 값이 큰 수를 표시할 때 효율적이지 목하다
* x*2^y 형태로 x와 y 값표시
* V = (-1)^s * M * 2^E
	* S 
		* 음수 또는 양수 표시 
		* 1비트임
	* M
		* 비율 이진수
		* n 비트 비율 필드 
	* E
		* 2의 제곱의 자릿값 제공
		* k 비트 지수 필드
* 단일 정밀도 float
* 이중 정밀도 double

* 정규화 값
	* exp 비트 파턴이 0 또는 1이 아님
		* 단일 정밀도는 255, 이중 정밀도는 2047
	* 이 때 지수. 필드는 부호형 정수를 bias 형태로 해석
* 비정규값
	* 지수 필드가 모두 0일 딴 비정규화
	* 목적
		* 정규화 숫자로는 항상 m >= 1 이므로 0 표시할 수 없음, 0을 표시할 방법 제공
		* 0.0에 매우 가까운 값 나타내기 위함
*speacial values
	* 지수. 필드가 1인 경우
	* 비율 필드가 0이면 결과는 무한대
	* 비율 필드가 0이 아니면 NaN
		* 초기화 되지 않은 데이터 표시
